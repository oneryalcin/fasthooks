{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"fasthooks","text":"<p>Delightful Claude Code hooks with a FastAPI-like developer experience.</p> <pre><code>from fasthooks import HookApp, deny\n\napp = HookApp()\n\n@app.pre_tool(\"Bash\")\ndef no_rm_rf(event):\n    if \"rm -rf\" in event.command:\n        return deny(\"Dangerous command blocked\")\n\nif __name__ == \"__main__\":\n    app.run()\n</code></pre>"},{"location":"#features","title":"Features","text":"<ul> <li>Typed events - Autocomplete for <code>event.command</code>, <code>event.file_path</code>, etc.</li> <li>Decorators - <code>@app.pre_tool(\"Bash\")</code>, <code>@app.on_stop()</code>, <code>@app.on_session_start()</code></li> <li>Dependency injection - <code>def handler(event, transcript: Transcript, state: State)</code></li> <li>Background tasks - Spawn async work that feeds back in subsequent hooks</li> <li>Claude sub-agents - Use Claude Agent SDK for AI-powered background tasks</li> <li>Blueprints - Compose handlers from multiple modules</li> <li>Middleware - Cross-cutting concerns like timing and logging</li> <li>Guards - <code>@app.pre_tool(\"Bash\", when=lambda e: \"sudo\" in e.command)</code></li> <li>Testing utilities - <code>MockEvent</code> and <code>TestClient</code> for easy testing</li> </ul>"},{"location":"#installation","title":"Installation","text":"pipuv <pre><code>pip install fasthooks\n</code></pre> <pre><code>uv add fasthooks\n</code></pre>"},{"location":"#quick-example","title":"Quick Example","text":"<pre><code>from fasthooks import HookApp, allow, deny\n\napp = HookApp()\n\n@app.pre_tool(\"Bash\")\ndef check_bash(event):\n    # event.command has autocomplete!\n    if \"rm -rf\" in event.command:\n        return deny(\"Dangerous command blocked\")\n    return allow()\n\n@app.pre_tool(\"Write\")\ndef check_write(event):\n    # event.file_path, event.content available\n    if event.file_path.endswith(\".env\"):\n        return deny(\"Cannot modify .env files\")\n    return allow()\n\n@app.on_stop()\ndef on_stop(event):\n    return allow()\n\nif __name__ == \"__main__\":\n    app.run()\n</code></pre>"},{"location":"#why-fasthooks","title":"Why fasthooks?","text":"<p>Claude Code hooks are powerful but the raw JSON protocol is tedious:</p> <ul> <li>No autocomplete for event fields</li> <li>Manual JSON parsing and response building</li> <li>No reusable patterns for common tasks</li> </ul> <p>fasthooks gives you a FastAPI-like experience:</p> Raw Hooks fasthooks Parse JSON from stdin Typed <code>event</code> objects Build JSON responses <code>allow()</code>, <code>deny()</code>, <code>block()</code> Manual dispatch <code>@app.pre_tool(\"Bash\")</code> Copy-paste boilerplate Blueprints &amp; middleware"},{"location":"#next-steps","title":"Next Steps","text":"<ul> <li>Getting Started - Set up your first hook project</li> <li>Tutorial - Learn fasthooks step by step</li> <li>CLI Reference - Command line tools</li> </ul>"},{"location":"architecture/","title":"Architecture","text":"<p>Low-level internals for contributors and advanced users.</p>"},{"location":"architecture/#claude-code-file-layout","title":"Claude Code File Layout","text":"<pre><code>~/.claude/\n\u251c\u2500\u2500 settings.json              # Global settings\n\u251c\u2500\u2500 settings.local.json        # Local overrides\n\u251c\u2500\u2500 CLAUDE.md                  # Global instructions\n\u251c\u2500\u2500 history.jsonl              # Command history\n\u2502\n\u251c\u2500\u2500 projects/                  # Per-project data\n\u2502   \u2514\u2500\u2500 &lt;escaped-cwd&gt;/         # e.g. -Users-john-myproject\n\u2502       \u251c\u2500\u2500 &lt;session-id&gt;.jsonl     # Main transcript\n\u2502       \u251c\u2500\u2500 agent-&lt;id&gt;.jsonl       # Subagent sidechains\n\u2502       \u2514\u2500\u2500 &lt;session-id&gt;/          # Session folder (rare)\n\u2502\n\u251c\u2500\u2500 session-env/               # Session environment data\n\u251c\u2500\u2500 file-history/              # File change history\n\u251c\u2500\u2500 plans/                     # Plan mode files\n\u2514\u2500\u2500 debug/                     # Debug logs\n</code></pre>"},{"location":"architecture/#path-escaping","title":"Path Escaping","text":"<p>Claude Code escapes the working directory path by replacing <code>/</code> with <code>-</code>:</p> <pre><code>/Users/john/myproject    \u2192  -Users-john-myproject\n/tmp/test                \u2192  -tmp-test\n/private/tmp/foo         \u2192  -private-tmp-foo\n</code></pre>"},{"location":"architecture/#transcript-files","title":"Transcript Files","text":"<p>Each session has a main transcript file: <pre><code>~/.claude/projects/-Users-john-myproject/abc123-def456.jsonl\n                   \u2514\u2500\u2500 escaped cwd \u2500\u2500\u2500\u2500\u2500\u2500\u2518\u2514\u2500 session id \u2500\u2518\n</code></pre></p> <p>Subagent sidechains (spawned via Task tool) are stored alongside: <pre><code>~/.claude/projects/-Users-john-myproject/agent-a1b2c3d.jsonl\n</code></pre></p>"},{"location":"architecture/#hook-invocation-flow","title":"Hook Invocation Flow","text":"<pre><code>\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 Claude Code (parent process)                                    \u2502\n\u2502                                                                 \u2502\n\u2502  1. User action triggers hook event                             \u2502\n\u2502  2. Claude Code spawns hook subprocess                          \u2502\n\u2502  3. Writes JSON to stdin:                                       \u2502\n\u2502     {                                                           \u2502\n\u2502       \"session_id\": \"abc123-...\",                               \u2502\n\u2502       \"hook_event_name\": \"PreToolUse\",                          \u2502\n\u2502       \"transcript_path\": \"~/.claude/projects/.../abc.jsonl\",    \u2502\n\u2502       \"cwd\": \"/Users/john/myproject\",                           \u2502\n\u2502       \"tool_name\": \"Bash\",                                      \u2502\n\u2502       \"tool_input\": {\"command\": \"ls -la\"}                       \u2502\n\u2502     }                                                           \u2502\n\u2502  4. Reads hook's stdout for response                            \u2502\n\u2502  5. Applies decision (allow/deny/block)                         \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                              \u2502\n                              \u25bc\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 fasthooks (hook subprocess)                                     \u2502\n\u2502                                                                 \u2502\n\u2502  app.run()                                                      \u2502\n\u2502    \u2502                                                            \u2502\n\u2502    \u251c\u2500&gt; _internal/io.py: read_stdin()                            \u2502\n\u2502    \u2502     \u2514\u2500&gt; Parse JSON from stdin                              \u2502\n\u2502    \u2502                                                            \u2502\n\u2502    \u251c\u2500&gt; _dispatch(data)                                          \u2502\n\u2502    \u2502     \u251c\u2500&gt; Route by hook_event_name                           \u2502\n\u2502    \u2502     \u251c\u2500&gt; Parse into typed Event (Bash, Write, etc.)         \u2502\n\u2502    \u2502     \u2514\u2500&gt; Find matching handlers                             \u2502\n\u2502    \u2502                                                            \u2502\n\u2502    \u251c\u2500&gt; _run_with_middleware(handlers, event)                    \u2502\n\u2502    \u2502     \u251c\u2500&gt; For each handler:                                  \u2502\n\u2502    \u2502     \u2502     \u251c\u2500&gt; _resolve_deps() \u2192 inject Transcript, State   \u2502\n\u2502    \u2502     \u2502     \u2514\u2500&gt; Call handler(event, **deps)                  \u2502\n\u2502    \u2502     \u2514\u2500&gt; Return first deny/block response                   \u2502\n\u2502    \u2502                                                            \u2502\n\u2502    \u2514\u2500&gt; _internal/io.py: write_stdout(response)                  \u2502\n\u2502          \u2514\u2500&gt; Write JSON response                                \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"architecture/#dependency-injection","title":"Dependency Injection","text":"<p>fasthooks injects dependencies based on type hints:</p> <pre><code>@app.pre_tool(\"Bash\")\ndef check(event, transcript: Transcript, state: State):\n    #          \u2191                 \u2191              \u2191\n    #      auto-passed     DI-injected    DI-injected\n</code></pre>"},{"location":"architecture/#how-di-works-apppy_resolve_deps","title":"How DI Works (app.py:_resolve_deps)","text":"<pre><code>def _resolve_deps(self, handler, event, cache):\n    hints = get_type_hints(handler)\n\n    for param_name, hint in hints.items():\n        if hint is Transcript:\n            # Extract path from event, create Transcript\n            transcript_path = getattr(event, \"transcript_path\", None)\n            deps[param_name] = Transcript(transcript_path)\n\n        elif hint is State:\n            # Create session-scoped State\n            deps[param_name] = State.for_session(\n                event.session_id,\n                state_dir=self.state_dir\n            )\n</code></pre>"},{"location":"architecture/#dependency-caching","title":"Dependency Caching","text":"<p>Dependencies are cached per-event to avoid redundant work:</p> <pre><code># If multiple handlers request Transcript, same instance is reused\ncache = {}\nfor handler in handlers:\n    deps = _resolve_deps(handler, event, cache)  # cache shared\n    handler(event, **deps)\n</code></pre>"},{"location":"architecture/#module-independence","title":"Module Independence","text":"<p>The transcript module is standalone - usable without hooks:</p> <pre><code>fasthooks/\n\u251c\u2500\u2500 app.py                    # HookApp - imports transcript\n\u251c\u2500\u2500 depends/\n\u2502   \u2514\u2500\u2500 transcript.py         # Re-exports for DI convenience\n\u2514\u2500\u2500 transcript/               # STANDALONE MODULE\n    \u251c\u2500\u2500 core.py               # Transcript class\n    \u251c\u2500\u2500 entries.py            # Entry types\n    \u251c\u2500\u2500 query.py              # TranscriptQuery\n    \u2514\u2500\u2500 ...\n</code></pre>"},{"location":"architecture/#standalone-usage","title":"Standalone Usage","text":"<pre><code># No HookApp, no events - just Transcript\nfrom fasthooks.transcript import Transcript\n\nt = Transcript(\"/path/to/transcript.jsonl\")\nt.query().assistants().with_tools().all()\nt.stats.input_tokens\n</code></pre>"},{"location":"architecture/#hook-integrated-usage","title":"Hook-Integrated Usage","text":"<pre><code># Via DI - path extracted from event automatically\nfrom fasthooks.depends import Transcript\n\n@app.pre_tool(\"Bash\")\ndef check(event, transcript: Transcript):\n    # transcript already loaded with correct session\n    pass\n</code></pre>"},{"location":"architecture/#event-routing","title":"Event Routing","text":"<pre><code>TOOL_EVENT_MAP = {\n    \"Bash\": Bash,\n    \"Write\": Write,\n    \"Read\": Read,\n    \"Edit\": Edit,\n    ...\n}\n\n# _dispatch routes by hook_event_name:\n# - PreToolUse/PostToolUse \u2192 tool handlers + catch-all (\"*\")\n# - Stop/SessionStart/etc. \u2192 lifecycle handlers\n</code></pre>"},{"location":"architecture/#handler-resolution-order","title":"Handler Resolution Order","text":"<ol> <li>Tool-specific handlers: <code>@app.pre_tool(\"Bash\")</code></li> <li>Catch-all handlers: <code>@app.pre_tool()</code> (matches all tools)</li> <li>First deny/block response wins</li> </ol>"},{"location":"architecture/#transcript-internals","title":"Transcript Internals","text":""},{"location":"architecture/#lazy-loading","title":"Lazy Loading","text":"<p>Transcript data is loaded on first access:</p> <pre><code>class Transcript:\n    def __init__(self, path):\n        self.path = Path(path) if path else None\n        self._loaded = False\n        self.entries = []\n\n    def _ensure_loaded(self):\n        if not self._loaded:\n            self.load()  # Parse JSONL file\n            self._loaded = True\n\n    @property\n    def stats(self):\n        self._ensure_loaded()  # Triggers load if needed\n        return self._stats\n</code></pre>"},{"location":"architecture/#entry-types","title":"Entry Types","text":"<pre><code>TranscriptEntry (union type)\n\u251c\u2500\u2500 UserMessage         # User input\n\u251c\u2500\u2500 AssistantMessage    # Claude response (may contain tool_use blocks)\n\u251c\u2500\u2500 SystemEntry         # System messages, summaries\n\u2514\u2500\u2500 FileHistorySnapshot # File state snapshots (not an Entry subclass)\n</code></pre>"},{"location":"architecture/#indexing","title":"Indexing","text":"<p>Transcript maintains indexes for fast lookups:</p> <pre><code>self._by_uuid: dict[str, Entry] = {}           # UUID \u2192 Entry\nself._children: dict[str, list[Entry]] = {}    # parent_uuid \u2192 children\n</code></pre>"},{"location":"architecture/#response-protocol","title":"Response Protocol","text":"<p>Hooks respond via stdout JSON:</p> <pre><code># Allow (continue execution)\n{\"decision\": \"allow\"}\n\n# Allow with message to user\n{\"decision\": \"allow\", \"hookSpecificOutput\": {\"message\": \"Approved\"}}\n\n# Deny (block this action, continue session)\n{\"decision\": \"deny\", \"reason\": \"Not allowed\"}\n\n# Block (show error to Claude, may retry)\n{\"decision\": \"block\", \"reason\": \"Rate limited\"}\n</code></pre> <p>Exit codes: - <code>0</code>: Success (response parsed) - <code>2</code>: Blocking error (stderr shown to Claude)</p>"},{"location":"architecture/#state-persistence","title":"State Persistence","text":"<p>State is session-scoped and persisted to JSON:</p> <pre><code>&lt;state_dir&gt;/&lt;session_id&gt;.json\n</code></pre> <pre><code>state = State.for_session(\"abc123\", state_dir=\"/tmp/state\")\nstate[\"count\"] = 1\nstate.save()  # Writes to /tmp/state/abc123.json\n</code></pre>"},{"location":"architecture/#background-tasks","title":"Background Tasks","text":"<p>Tasks run in separate processes, results retrieved later:</p> <pre><code>@app.pre_tool(\"Write\")\ndef on_write(event, tasks: Tasks):\n    tasks.add(analyze, event.content)  # Enqueue\n\n@app.on_prompt()\ndef check(event, tasks: Tasks):\n    if result := tasks.pop(analyze):   # Retrieve\n        return allow(message=result)\n</code></pre> <p>Backend options: - <code>InMemoryBackend</code>: Default, single-process - Custom backends for distributed execution</p>"},{"location":"cli/","title":"CLI Reference","text":"<p>fasthooks provides command-line tools for creating and testing hooks.</p>"},{"location":"cli/#commands","title":"Commands","text":""},{"location":"cli/#fasthooks-init","title":"fasthooks init","text":"<p>Create a new hooks project:</p> <pre><code>fasthooks init my-hooks\n</code></pre> <p>Creates:</p> <pre><code>my-hooks/\n\u251c\u2500\u2500 hooks.py              # Your hook handlers\n\u251c\u2500\u2500 pyproject.toml        # Project dependencies\n\u2514\u2500\u2500 .claude/\n    \u2514\u2500\u2500 settings.json     # Claude Code configuration\n</code></pre> <p>The generated <code>hooks.py</code> includes inline script dependencies for use with <code>uv run</code>:</p> <pre><code># /// script\n# dependencies = [\"fasthooks\"]\n# ///\nfrom fasthooks import HookApp, allow, deny\n...\n</code></pre>"},{"location":"cli/#fasthooks-run","title":"fasthooks run","text":"<p>Run a hooks file:</p> <pre><code># Normal mode (reads from stdin, writes to stdout)\nfasthooks run hooks.py\n\n# Test mode with input file\nfasthooks run hooks.py --input event.json\n</code></pre> <p>Options:</p> Option Short Description <code>--input</code> <code>-i</code> JSON file to use as input instead of stdin"},{"location":"cli/#fasthooks-example","title":"fasthooks example","text":"<p>Generate sample event JSON for testing:</p> <pre><code># List available event types\nfasthooks example --help\n\n# Generate specific events\nfasthooks example bash\nfasthooks example bash_dangerous\nfasthooks example write\nfasthooks example stop\n</code></pre> <p>Available event types:</p> Type Description <code>bash</code> Safe bash command (<code>echo hello</code>) <code>bash_dangerous</code> Dangerous command (<code>rm -rf /</code>) <code>write</code> Write file event <code>read</code> Read file event <code>edit</code> Edit file event <code>stop</code> Stop event <code>session_start</code> Session start event <code>pre_compact</code> Pre-compact event <code>permission_bash</code> Permission request for bash <code>permission_write</code> Permission request for write <code>permission_edit</code> Permission request for edit"},{"location":"cli/#fasthooks-help","title":"fasthooks --help","text":"<p>Show help and available commands:</p> <pre><code>fasthooks --help\nfasthooks init --help\nfasthooks run --help\nfasthooks example --help\n</code></pre>"},{"location":"cli/#fasthooks-version","title":"fasthooks --version","text":"<p>Show version:</p> <pre><code>fasthooks --version\n</code></pre>"},{"location":"cli/#workflow-example","title":"Workflow Example","text":"<p>Complete local testing workflow:</p> <pre><code># 1. Create project\nfasthooks init my-hooks\ncd my-hooks\n\n# 2. Edit hooks.py with your handlers\n# ...\n\n# 3. Generate test event\nfasthooks example bash_dangerous &gt; event.json\n\n# 4. Test your hook\nfasthooks run hooks.py --input event.json\n# Output: {\"decision\": \"deny\", \"reason\": \"...\"}\n\n# 5. Test with safe event\nfasthooks example bash &gt; safe.json\nfasthooks run hooks.py --input safe.json\n# No output = allowed\n</code></pre>"},{"location":"getting-started/","title":"Getting Started","text":"<p>Get your first Claude Code hook running in 5 minutes.</p>"},{"location":"getting-started/#prerequisites","title":"Prerequisites","text":"<ul> <li>Python 3.11+</li> <li>uv (recommended) or pip</li> <li>Claude Code CLI</li> </ul>"},{"location":"getting-started/#create-a-hook-project","title":"Create a Hook Project","text":"<pre><code>fasthooks init my-hooks\ncd my-hooks\n</code></pre> <p>This creates:</p> <pre><code>my-hooks/\n\u251c\u2500\u2500 hooks.py              # Your hook handlers\n\u251c\u2500\u2500 pyproject.toml        # Project dependencies\n\u2514\u2500\u2500 .claude/\n    \u2514\u2500\u2500 settings.json     # Claude Code configuration\n</code></pre>"},{"location":"getting-started/#your-first-hook","title":"Your First Hook","text":"<p>Edit <code>hooks.py</code>:</p> <pre><code># /// script\n# dependencies = [\"fasthooks\"]\n# ///\nfrom fasthooks import HookApp, allow, deny\n\napp = HookApp()\n\n@app.pre_tool(\"Bash\")\ndef check_bash(event):\n    \"\"\"Block dangerous bash commands.\"\"\"\n    if \"rm -rf\" in event.command:\n        return deny(\"Dangerous command blocked\")\n    return allow()\n\nif __name__ == \"__main__\":\n    app.run()\n</code></pre>"},{"location":"getting-started/#test-locally","title":"Test Locally","text":"<p>Generate a sample event and test your hook:</p> <pre><code># Generate a dangerous bash event\nfasthooks example bash_dangerous &gt; event.json\n\n# Run your hook\nfasthooks run hooks.py --input event.json\n</code></pre> <p>Output: <pre><code>{\"decision\": \"deny\", \"reason\": \"Dangerous command blocked\"}\n</code></pre></p> <p>Try with a safe command:</p> <pre><code>fasthooks example bash &gt; safe.json\nfasthooks run hooks.py --input safe.json\n</code></pre> <p>No output means the command is allowed.</p>"},{"location":"getting-started/#configure-claude-code","title":"Configure Claude Code","text":"<p>Copy the generated settings to your project:</p> <pre><code>cp .claude/settings.json /path/to/your/project/.claude/\n</code></pre> <p>Or add to your global Claude Code settings (<code>~/.claude/settings.json</code>):</p> <pre><code>{\n  \"hooks\": {\n    \"PreToolUse\": [\n      {\n        \"matcher\": \"*\",\n        \"hooks\": [\n          {\n            \"type\": \"command\",\n            \"command\": \"uv run /path/to/my-hooks/hooks.py\"\n          }\n        ]\n      }\n    ]\n  }\n}\n</code></pre>"},{"location":"getting-started/#how-it-works","title":"How It Works","text":"<ol> <li>Claude Code calls your hook via stdin/stdout</li> <li><code>app.run()</code> reads the JSON event from stdin</li> <li>Your handler receives a typed <code>event</code> object</li> <li>Return <code>allow()</code>, <code>deny(reason)</code>, or <code>None</code></li> <li>fasthooks writes the JSON response to stdout</li> </ol> <pre><code>Claude Code \u2192 stdin (JSON) \u2192 fasthooks \u2192 handler \u2192 response \u2192 stdout \u2192 Claude Code\n</code></pre>"},{"location":"getting-started/#next-steps","title":"Next Steps","text":"<ul> <li>Events - Learn about different event types</li> <li>Responses - Understand <code>allow()</code>, <code>deny()</code>, <code>block()</code></li> <li>Testing - Write tests for your hooks</li> </ul>"},{"location":"reference/","title":"API Reference","text":"<p>Quick reference for fasthooks classes and functions.</p>"},{"location":"reference/#hookapp","title":"HookApp","text":"<p>Main application class.</p> <pre><code>from fasthooks import HookApp\n\napp = HookApp(\n    state_dir=None,       # Directory for persistent state files\n    log_dir=None,         # Directory for JSONL event logs\n    log_level=\"INFO\",     # Logging verbosity\n    task_backend=None,    # Backend for background tasks (default: InMemoryBackend)\n)\n</code></pre>"},{"location":"reference/#decorators","title":"Decorators","text":"<pre><code># Tool events\n@app.pre_tool(\"Bash\")           # Before tool executes\n@app.pre_tool(\"*\")              # All tools\n@app.post_tool(\"Write\")         # After tool executes\n@app.on_permission(\"Bash\")      # Permission dialog shown\n\n# Lifecycle events\n@app.on_stop()                  # Claude stops\n@app.on_subagent_stop()         # Subagent stops\n@app.on_session_start()         # Session starts\n@app.on_session_end()           # Session ends\n@app.on_notification()          # Notification sent\n@app.on_pre_compact()           # Before compaction\n@app.on_prompt()                # User submits prompt\n</code></pre>"},{"location":"reference/#guards","title":"Guards","text":"<pre><code>@app.pre_tool(\"Bash\", when=lambda e: \"sudo\" in e.command)\ndef check_sudo(event):\n    return deny(\"No sudo\")\n</code></pre>"},{"location":"reference/#methods","title":"Methods","text":"<pre><code>app.run()                       # Run the hook (reads stdin, writes stdout)\napp.include(blueprint)          # Include handlers from a Blueprint\n</code></pre>"},{"location":"reference/#responses","title":"Responses","text":"<pre><code>from fasthooks import allow, deny, block\n\n# Allow the action\nallow()\nallow(message=\"Warning: sensitive file\")\n\n# Deny the action (PreToolUse, PermissionRequest)\ndeny(\"Reason shown to Claude\")\ndeny(\"Reason\", interrupt=True)  # Stop Claude entirely\n\n# Block stopping (Stop, SubagentStop)\nblock(\"Reason to continue\")\n</code></pre>"},{"location":"reference/#events","title":"Events","text":""},{"location":"reference/#base-fields-all-events","title":"Base Fields (all events)","text":"<pre><code>event.session_id        # str\nevent.cwd               # str\nevent.permission_mode   # str\nevent.transcript_path   # str | None\nevent.hook_event_name   # str\n</code></pre>"},{"location":"reference/#tool-events","title":"Tool Events","text":"<pre><code>event.tool_name         # str\nevent.tool_input        # dict\nevent.tool_use_id       # str\nevent.tool_response     # dict | None (PostToolUse only)\n</code></pre>"},{"location":"reference/#typed-tool-properties","title":"Typed Tool Properties","text":"Tool Properties Bash <code>command</code>, <code>description</code>, <code>timeout</code> Write <code>file_path</code>, <code>content</code> Edit <code>file_path</code>, <code>old_string</code>, <code>new_string</code> Read <code>file_path</code>, <code>offset</code>, <code>limit</code> Grep <code>pattern</code>, <code>path</code> Glob <code>pattern</code>, <code>path</code>"},{"location":"reference/#lifecycle-events","title":"Lifecycle Events","text":"Event Properties Stop <code>stop_hook_active</code> SessionStart <code>source</code> SessionEnd <code>reason</code> PreCompact <code>trigger</code>, <code>custom_instructions</code> UserPromptSubmit <code>prompt</code> Notification <code>message</code>, <code>notification_type</code>"},{"location":"reference/#testing","title":"Testing","text":"<pre><code>from fasthooks.testing import MockEvent, TestClient\n\n# Create mock events\nMockEvent.bash(command=\"ls\")\nMockEvent.write(file_path=\"/tmp/f.txt\", content=\"...\")\nMockEvent.stop()\n\n# Test client\nclient = TestClient(app)\nresponse = client.send(MockEvent.bash(command=\"rm -rf /\"))\nassert response.decision == \"deny\"\n</code></pre>"},{"location":"reference/#dependency-injection","title":"Dependency Injection","text":"<pre><code>from fasthooks.depends import State, Transcript\nfrom fasthooks.tasks import Tasks\n\n@app.pre_tool(\"Bash\")\ndef handler(event, state: State, transcript: Transcript):\n    # state: persistent dict across hook calls\n    state[\"count\"] = state.get(\"count\", 0) + 1\n\n    # transcript: parsed conversation history\n    stats = transcript.stats\n    print(f\"Tokens: {stats.total_tokens}\")\n\n@app.pre_tool(\"Write\")\ndef with_tasks(event, tasks: Tasks):\n    # tasks: spawn background work + retrieve completed results\n    pass\n</code></pre>"},{"location":"reference/#background-tasks","title":"Background Tasks","text":""},{"location":"reference/#task-definition","title":"Task Definition","text":"<pre><code>from fasthooks.tasks import task\n\n@task\ndef simple_task(x: int) -&gt; int:\n    return x * 2\n\n@task(ttl=600, priority=5)\ndef with_options(query: str) -&gt; str:\n    return search(query)\n\n@task(transform=lambda r: r[:100])\ndef with_transform() -&gt; str:\n    return long_string()\n</code></pre>"},{"location":"reference/#tasks-recommended","title":"Tasks (recommended)","text":"<pre><code>from fasthooks.tasks import Tasks\n\n@app.pre_tool(\"Write\")\ndef handler(event, tasks: Tasks):\n    # Default key is the function name; use explicit key for concurrent calls\n    tasks.add(my_task, arg1)\n    tasks.add(other_task, data, key=\"other:1\")\n\n    # Pop by function reference (no string typos)\n    result = tasks.pop(my_task)\n</code></pre>"},{"location":"reference/#backgroundtasks","title":"BackgroundTasks","text":"<pre><code>from fasthooks.tasks import BackgroundTasks\n\n@app.pre_tool(\"Write\")\ndef handler(event, tasks: BackgroundTasks):\n    tasks.add(my_task, arg1, key=\"unique-key\")\n    tasks.add(other_task, data, key=\"other\", ttl=600)\n    tasks.cancel(\"unique-key\")\n    tasks.cancel_all()\n</code></pre>"},{"location":"reference/#pendingresults","title":"PendingResults","text":"<pre><code>from fasthooks.tasks import PendingResults\n\n@app.on_prompt()\ndef handler(event, pending: PendingResults):\n    result = pending.pop(\"key\")              # Pop completed result\n    results = pending.pop_all()              # Pop all completed\n    errors = pending.pop_errors()            # Pop failed as [(key, error), ...]\n    task_result = pending.get(\"key\")         # Get TaskResult without removing\n    has_results = pending.has(\"key\")         # Check if ready\n\n    # Async waiting\n    result = await pending.wait(\"key\", timeout=10.0)\n    results = await pending.wait_all([\"k1\", \"k2\"], timeout=30.0)\n    key, result = await pending.wait_any([\"k1\", \"k2\"])\n</code></pre>"},{"location":"reference/#taskresult","title":"TaskResult","text":"<pre><code>from fasthooks.tasks import TaskResult, TaskStatus\n\nresult: TaskResult\nresult.id           # str - Unique task ID\nresult.session_id   # str - Session that created this task\nresult.key          # str - User-provided key\nresult.status       # TaskStatus - PENDING, RUNNING, COMPLETED, FAILED, CANCELLED\nresult.value        # Any - Result value (if completed)\nresult.error        # Exception | None - Error (if failed)\nresult.is_finished  # bool - True if done (success, fail, or cancelled)\n</code></pre>"},{"location":"reference/#claude-agent-sdk-integration","title":"Claude Agent SDK Integration","text":"<p>Requires: <code>pip install fasthooks[claude]</code></p>"},{"location":"reference/#claudeagent","title":"ClaudeAgent","text":"<pre><code>from fasthooks.contrib.claude import ClaudeAgent\n\nagent = ClaudeAgent(\n    model=\"haiku\",                    # haiku, sonnet, opus\n    system_prompt=\"You are helpful.\",\n    allowed_tools=[\"Read\", \"Grep\"],\n    max_turns=5,\n    max_budget_usd=0.10,\n    cwd=\"/path/to/project\",\n)\n\n# Query Claude\nresponse = await agent.query(\"What is 2+2?\")\n\n# Override per-query\nresponse = await agent.query(\n    \"Analyze this\",\n    system_prompt=\"Override prompt\",\n    max_turns=3,\n)\n\n# As context manager\nasync with ClaudeAgent(model=\"haiku\") as agent:\n    response = await agent.query(\"Hello\")\n</code></pre>"},{"location":"reference/#agent_task-decorator","title":"@agent_task Decorator","text":"<pre><code>from fasthooks.contrib.claude import ClaudeAgent, agent_task\n\n@agent_task(\n    model=\"haiku\",\n    system_prompt=\"You review code.\",\n    allowed_tools=[\"Read\"],\n    ttl=600,\n    priority=5,\n)\nasync def review_code(agent: ClaudeAgent, code: str) -&gt; str:\n    return await agent.query(f\"Review:\\n{code}\")\n\n# Use with Tasks\n@app.pre_tool(\"Write\")\ndef on_write(event, tasks: Tasks):\n    tasks.add(review_code, event.content)\n</code></pre>"},{"location":"reference/#blueprint","title":"Blueprint","text":"<pre><code>from fasthooks import Blueprint\n\nsecurity = Blueprint()\n\n@security.pre_tool(\"Bash\")\ndef check(event):\n    ...\n\n# In main app\napp.include(security)\n</code></pre>"},{"location":"api/","title":"Python API Reference","text":"<p>Auto-generated API documentation from source code docstrings.</p>"},{"location":"api/#modules","title":"Modules","text":"Module Description HookApp Main application class Responses Response builders (<code>allow</code>, <code>deny</code>, <code>block</code>) Events Event types for tools and lifecycle Dependencies Injectable dependencies (<code>Transcript</code>, <code>State</code>) Transcript Rich transcript modeling and context engineering Tasks Background task system Claude Integration Claude Agent SDK wrapper Testing Testing utilities"},{"location":"api/#quick-links","title":"Quick Links","text":"<pre><code># Core\nfrom fasthooks import HookApp, Blueprint\nfrom fasthooks import allow, deny, block\n\n# Dependencies\nfrom fasthooks.depends import Transcript, State\n\n# Transcript (context engineering)\nfrom fasthooks.transcript import (\n    Transcript,\n    UserMessage,\n    AssistantMessage,\n    inject_tool_result,\n)\n\n# Background Tasks\nfrom fasthooks.tasks import task, Tasks\n\n# Claude Integration (optional)\nfrom fasthooks.contrib.claude import ClaudeAgent, agent_task\n\n# Testing\nfrom fasthooks.testing import MockEvent, TestClient\n</code></pre>"},{"location":"api/app/","title":"HookApp","text":"<p>The main application class for registering and running hook handlers.</p>"},{"location":"api/app/#fasthooks.app.HookApp","title":"HookApp","text":"<p>               Bases: <code>HandlerRegistry</code></p> <p>Main application for registering and running hook handlers.</p>"},{"location":"api/app/#fasthooks.app.HookApp.__init__","title":"__init__","text":"<pre><code>__init__(\n    state_dir: str | None = None,\n    log_dir: str | None = None,\n    log_level: str = \"INFO\",\n    task_backend: BaseBackend | None = None,\n)\n</code></pre> <p>Initialize HookApp.</p> <p>Parameters:</p> Name Type Description Default <code>state_dir</code> <code>str | None</code> <p>Directory for persistent state files</p> <code>None</code> <code>log_dir</code> <code>str | None</code> <p>Directory for JSONL event logs (enables built-in logging)</p> <code>None</code> <code>log_level</code> <code>str</code> <p>Logging verbosity</p> <code>'INFO'</code> <code>task_backend</code> <code>BaseBackend | None</code> <p>Backend for background tasks (default: InMemoryBackend)</p> <code>None</code>"},{"location":"api/app/#fasthooks.app.HookApp.run","title":"run","text":"<pre><code>run(\n    stdin: IO[str] | None = None,\n    stdout: IO[str] | None = None,\n) -&gt; None\n</code></pre> <p>Run the hook app, processing stdin and writing to stdout.</p> <p>Parameters:</p> Name Type Description Default <code>stdin</code> <code>IO[str] | None</code> <p>Input stream (default: sys.stdin)</p> <code>None</code> <code>stdout</code> <code>IO[str] | None</code> <p>Output stream (default: sys.stdout)</p> <code>None</code>"},{"location":"api/app/#fasthooks.app.HookApp.include","title":"include","text":"<pre><code>include(blueprint: Blueprint) -&gt; None\n</code></pre> <p>Include a blueprint's handlers.</p> <p>Parameters:</p> Name Type Description Default <code>blueprint</code> <code>Blueprint</code> <p>Blueprint to include</p> required"},{"location":"api/app/#fasthooks.app.HookApp.middleware","title":"middleware","text":"<pre><code>middleware(func: Callable[..., Any]) -&gt; Callable[..., Any]\n</code></pre> <p>Decorator to register middleware.</p> <p>Middleware wraps all handler calls and can: - Execute code before/after handlers - Short-circuit by returning a response - Modify events or responses</p> Example <p>@app.middleware def timing(event, call_next):     start = time.time()     response = call_next(event)     print(f\"Took {time.time() - start:.3f}s\")     return response</p>"},{"location":"api/app/#blueprint","title":"Blueprint","text":"<p>Composable handler groups for organizing hooks.</p>"},{"location":"api/app/#fasthooks.blueprint.Blueprint","title":"Blueprint","text":"<p>               Bases: <code>HandlerRegistry</code></p> <p>Composable collection of hook handlers.</p> <p>Use blueprints to organize handlers into logical groups that can be included in the main HookApp.</p> Example <p>security = Blueprint(\"security\")</p> <p>@security.pre_tool(\"Bash\") def no_sudo(event):     if \"sudo\" in event.command:         return deny(\"sudo not allowed\")</p> <p>app = HookApp() app.include(security)</p>"},{"location":"api/app/#fasthooks.blueprint.Blueprint.__init__","title":"__init__","text":"<pre><code>__init__(name: str)\n</code></pre> <p>Initialize Blueprint.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Name for this blueprint (for debugging)</p> required"},{"location":"api/contrib-claude/","title":"Claude Agent SDK Integration","text":"<p>Integration with Claude Agent SDK for AI-powered background tasks.</p> <p>Optional Dependency</p> <p>Requires <code>pip install fasthooks[claude]</code></p>"},{"location":"api/contrib-claude/#claudeagent","title":"ClaudeAgent","text":""},{"location":"api/contrib-claude/#fasthooks.contrib.claude.agent.ClaudeAgent","title":"ClaudeAgent  <code>dataclass</code>","text":"<p>Simplified wrapper for Claude Agent SDK.</p> <p>Provides a simple interface for querying Claude in background tasks.</p> Usage <p>agent = ClaudeAgent(model=\"haiku\", system_prompt=\"You are helpful.\")</p> Context manager usage <p>async with ClaudeAgent(model=\"sonnet\") as agent:     response = await agent.query(\"Explain this code\")</p>"},{"location":"api/contrib-claude/#fasthooks.contrib.claude.agent.ClaudeAgent--simple-query","title":"Simple query","text":"<p>response = await agent.query(\"What is 2+2?\")</p>"},{"location":"api/contrib-claude/#fasthooks.contrib.claude.agent.ClaudeAgent--with-tools","title":"With tools","text":"<p>agent = ClaudeAgent(allowed_tools=[\"Read\", \"Grep\"]) response = await agent.query(\"Find all TODO comments in src/\")</p>"},{"location":"api/contrib-claude/#fasthooks.contrib.claude.agent.ClaudeAgent.model","title":"model  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>model: Model | str | None = None\n</code></pre>"},{"location":"api/contrib-claude/#fasthooks.contrib.claude.agent.ClaudeAgent.system_prompt","title":"system_prompt  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>system_prompt: str | None = None\n</code></pre>"},{"location":"api/contrib-claude/#fasthooks.contrib.claude.agent.ClaudeAgent.allowed_tools","title":"allowed_tools  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>allowed_tools: list[str] = field(default_factory=list)\n</code></pre>"},{"location":"api/contrib-claude/#fasthooks.contrib.claude.agent.ClaudeAgent.max_turns","title":"max_turns  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>max_turns: int | None = None\n</code></pre>"},{"location":"api/contrib-claude/#fasthooks.contrib.claude.agent.ClaudeAgent.max_budget_usd","title":"max_budget_usd  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>max_budget_usd: float | None = None\n</code></pre>"},{"location":"api/contrib-claude/#fasthooks.contrib.claude.agent.ClaudeAgent.cwd","title":"cwd  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>cwd: str | None = None\n</code></pre>"},{"location":"api/contrib-claude/#fasthooks.contrib.claude.agent.ClaudeAgent.query","title":"query  <code>async</code>","text":"<pre><code>query(\n    prompt: str,\n    *,\n    system_prompt: str | None = None,\n    allowed_tools: list[str] | None = None,\n    max_turns: int | None = None,\n    max_budget_usd: float | None = None,\n    cwd: str | None = None,\n) -&gt; str\n</code></pre> <p>Query Claude and return the text response.</p> <p>Parameters:</p> Name Type Description Default <code>prompt</code> <code>str</code> <p>The prompt to send to Claude</p> required <code>system_prompt</code> <code>str | None</code> <p>Override system prompt for this query</p> <code>None</code> <code>allowed_tools</code> <code>list[str] | None</code> <p>Override allowed tools for this query</p> <code>None</code> <code>max_turns</code> <code>int | None</code> <p>Override max turns for this query</p> <code>None</code> <code>max_budget_usd</code> <code>float | None</code> <p>Override budget limit for this query</p> <code>None</code> <code>cwd</code> <code>str | None</code> <p>Override working directory for this query</p> <code>None</code> <p>Returns:</p> Type Description <code>str</code> <p>The text response from Claude</p> <p>Raises:</p> Type Description <code>ImportError</code> <p>If claude-agent-sdk is not installed</p> <code>Exception</code> <p>If the query fails</p>"},{"location":"api/contrib-claude/#fasthooks.contrib.claude.agent.ClaudeAgent.__aenter__","title":"__aenter__  <code>async</code>","text":"<pre><code>__aenter__() -&gt; ClaudeAgent\n</code></pre> <p>Enter async context.</p>"},{"location":"api/contrib-claude/#fasthooks.contrib.claude.agent.ClaudeAgent.__aexit__","title":"__aexit__  <code>async</code>","text":"<pre><code>__aexit__(exc_type: Any, exc_val: Any, exc_tb: Any) -&gt; None\n</code></pre> <p>Exit async context.</p>"},{"location":"api/contrib-claude/#agent_task-decorator","title":"agent_task Decorator","text":""},{"location":"api/contrib-claude/#fasthooks.contrib.claude.agent.agent_task","title":"agent_task","text":"<pre><code>agent_task(\n    model: Model | str = \"haiku\",\n    system_prompt: str | None = None,\n    allowed_tools: list[str] | None = None,\n    max_turns: int | None = None,\n    max_budget_usd: float | None = None,\n    *,\n    ttl: int = 300,\n    priority: int = 0,\n) -&gt; Callable[[Callable[..., Any]], Task]\n</code></pre> <p>Decorator to create a background task that uses Claude Agent.</p> <p>The decorated function receives a <code>ClaudeAgent</code> instance as its first argument, pre-configured with the specified options.</p> Usage <p>@agent_task(model=\"haiku\", system_prompt=\"You are a code reviewer.\") async def review_code(agent: ClaudeAgent, code: str) -&gt; str:     return await agent.query(f\"Review this code:\\n{code}\")</p> <p>Parameters:</p> Name Type Description Default <code>model</code> <code>Model | str</code> <p>Claude model to use (haiku, sonnet, opus)</p> <code>'haiku'</code> <code>system_prompt</code> <code>str | None</code> <p>System prompt for the agent</p> <code>None</code> <code>allowed_tools</code> <code>list[str] | None</code> <p>Tools the agent can use</p> <code>None</code> <code>max_turns</code> <code>int | None</code> <p>Maximum conversation turns</p> <code>None</code> <code>max_budget_usd</code> <code>float | None</code> <p>Budget limit for the query</p> <code>None</code> <code>ttl</code> <code>int</code> <p>Time-to-live for task result (seconds)</p> <code>300</code> <code>priority</code> <code>int</code> <p>Task priority (higher = more important)</p> <code>0</code> <p>Returns:</p> Type Description <code>Callable[[Callable[..., Any]], Task]</code> <p>Task decorator</p>"},{"location":"api/contrib-claude/#fasthooks.contrib.claude.agent.agent_task--then-use-in-a-handler","title":"Then use in a handler:","text":"<p>@app.pre_tool(\"Write\") def on_write(event, tasks: BackgroundTasks):     tasks.add(review_code, event.content, key=\"review\")</p>"},{"location":"api/contrib-claude/#type-aliases","title":"Type Aliases","text":"<pre><code># Model type hint\nModel = Literal[\"sonnet\", \"opus\", \"haiku\"]\n</code></pre>"},{"location":"api/depends/","title":"Dependencies","text":"<p>Injectable dependencies for hook handlers.</p>"},{"location":"api/depends/#transcript","title":"Transcript","text":"<p>Access to the conversation history and statistics. See Transcript API for full documentation.</p>"},{"location":"api/depends/#fasthooks.depends.transcript.Transcript","title":"Transcript","text":"<p>Mutable collection of entries backed by a JSONL file.</p> Usage"},{"location":"api/depends/#fasthooks.depends.transcript.Transcript--standalone","title":"Standalone","text":"<p>transcript = Transcript(\"/path/to/transcript.jsonl\") transcript.load()</p>"},{"location":"api/depends/#fasthooks.depends.transcript.Transcript--query","title":"Query","text":"<p>for msg in transcript.user_messages:     print(msg.text)</p>"},{"location":"api/depends/#fasthooks.depends.transcript.Transcript.stats","title":"stats  <code>property</code>","text":"<pre><code>stats: 'TranscriptStats'\n</code></pre> <p>Calculate transcript statistics.</p>"},{"location":"api/depends/#fasthooks.depends.transcript.Transcript.entries","title":"entries  <code>instance-attribute</code>","text":"<pre><code>entries: list[TranscriptEntry] = []\n</code></pre>"},{"location":"api/depends/#fasthooks.depends.transcript.Transcript.user_messages","title":"user_messages  <code>property</code>","text":"<pre><code>user_messages: list[UserMessage]\n</code></pre> <p>All user messages (uses default include_archived setting).</p>"},{"location":"api/depends/#fasthooks.depends.transcript.Transcript.assistant_messages","title":"assistant_messages  <code>property</code>","text":"<pre><code>assistant_messages: list[AssistantMessage]\n</code></pre> <p>All assistant messages (uses default include_archived setting).</p>"},{"location":"api/depends/#fasthooks.depends.transcript.Transcript.tool_uses","title":"tool_uses  <code>property</code>","text":"<pre><code>tool_uses: list[ToolUseBlock]\n</code></pre> <p>All tool use blocks across all messages.</p>"},{"location":"api/depends/#fasthooks.depends.transcript.Transcript.tool_results","title":"tool_results  <code>property</code>","text":"<pre><code>tool_results: list[ToolResultBlock]\n</code></pre> <p>All tool result blocks.</p>"},{"location":"api/depends/#fasthooks.depends.transcript.Transcript.__init__","title":"__init__","text":"<pre><code>__init__(\n    path: str | Path | None = None,\n    validate: Literal[\"strict\", \"warn\", \"none\"] = \"warn\",\n    safety: Literal[\"strict\", \"warn\", \"none\"] = \"warn\",\n    auto_load: bool = True,\n)\n</code></pre>"},{"location":"api/depends/#fasthooks.depends.transcript.Transcript.query","title":"query","text":"<pre><code>query(\n    include_archived: bool | None = None,\n    include_meta: bool | None = None,\n) -&gt; TranscriptQuery\n</code></pre> <p>Start a fluent query on transcript entries.</p> Returns a TranscriptQuery that supports chaining <p>transcript.query().filter(type=\"assistant\").first() transcript.query().assistants().with_tools().count()</p> <p>Parameters:</p> Name Type Description Default <code>include_archived</code> <code>bool | None</code> <p>Include archived entries. Defaults to self.include_archived.</p> <code>None</code> <code>include_meta</code> <code>bool | None</code> <p>Include meta entries. Defaults to self.include_meta.</p> <code>None</code> <p>Returns:</p> Type Description <code>TranscriptQuery</code> <p>TranscriptQuery for fluent chaining</p>"},{"location":"api/depends/#fasthooks.depends.transcript.TranscriptStats","title":"TranscriptStats","text":"<p>Statistics extracted from a transcript.</p>"},{"location":"api/depends/#fasthooks.depends.transcript.TranscriptStats.input_tokens","title":"input_tokens  <code>instance-attribute</code>","text":"<pre><code>input_tokens = input_tokens\n</code></pre>"},{"location":"api/depends/#fasthooks.depends.transcript.TranscriptStats.output_tokens","title":"output_tokens  <code>instance-attribute</code>","text":"<pre><code>output_tokens = output_tokens\n</code></pre>"},{"location":"api/depends/#fasthooks.depends.transcript.TranscriptStats.cache_read_tokens","title":"cache_read_tokens  <code>instance-attribute</code>","text":"<pre><code>cache_read_tokens = cache_read_tokens\n</code></pre>"},{"location":"api/depends/#fasthooks.depends.transcript.TranscriptStats.cache_creation_tokens","title":"cache_creation_tokens  <code>instance-attribute</code>","text":"<pre><code>cache_creation_tokens = cache_creation_tokens\n</code></pre>"},{"location":"api/depends/#fasthooks.depends.transcript.TranscriptStats.tool_calls","title":"tool_calls  <code>instance-attribute</code>","text":"<pre><code>tool_calls = tool_calls or {}\n</code></pre>"},{"location":"api/depends/#fasthooks.depends.transcript.TranscriptStats.error_count","title":"error_count  <code>instance-attribute</code>","text":"<pre><code>error_count = error_count\n</code></pre>"},{"location":"api/depends/#fasthooks.depends.transcript.TranscriptStats.message_count","title":"message_count  <code>instance-attribute</code>","text":"<pre><code>message_count = message_count\n</code></pre>"},{"location":"api/depends/#fasthooks.depends.transcript.TranscriptStats.turn_count","title":"turn_count  <code>instance-attribute</code>","text":"<pre><code>turn_count = turn_count\n</code></pre>"},{"location":"api/depends/#fasthooks.depends.transcript.TranscriptStats.compact_count","title":"compact_count  <code>instance-attribute</code>","text":"<pre><code>compact_count = compact_count\n</code></pre>"},{"location":"api/depends/#fasthooks.depends.transcript.TranscriptStats.duration_seconds","title":"duration_seconds  <code>instance-attribute</code>","text":"<pre><code>duration_seconds = duration_seconds\n</code></pre>"},{"location":"api/depends/#fasthooks.depends.transcript.TranscriptStats.slug","title":"slug  <code>instance-attribute</code>","text":"<pre><code>slug = slug\n</code></pre>"},{"location":"api/depends/#state","title":"State","text":"<p>Persistent session-scoped storage.</p>"},{"location":"api/depends/#fasthooks.depends.state.State","title":"State","text":"<p>               Bases: <code>dict[str, Any]</code></p> <p>Persistent dict backed by JSON file.</p> <p>Behaves like a regular dict but can save/load from file. Use as context manager for auto-save on exit.</p>"},{"location":"api/depends/#fasthooks.depends.state.State.for_session","title":"for_session  <code>classmethod</code>","text":"<pre><code>for_session(\n    session_id: str, state_dir: Path | str\n) -&gt; State\n</code></pre> <p>Create state scoped to a session.</p> <p>Parameters:</p> Name Type Description Default <code>session_id</code> <code>str</code> <p>Session identifier</p> required <code>state_dir</code> <code>Path | str</code> <p>Directory for state files</p> required <p>Returns:</p> Type Description <code>State</code> <p>State instance for this session</p>"},{"location":"api/depends/#fasthooks.depends.state.State.save","title":"save","text":"<pre><code>save() -&gt; None\n</code></pre> <p>Save state to file.</p>"},{"location":"api/events/","title":"Events","text":"<p>Event types for tools and lifecycle hooks.</p>"},{"location":"api/events/#base-event","title":"Base Event","text":""},{"location":"api/events/#fasthooks.events.base.BaseEvent","title":"BaseEvent","text":"<p>               Bases: <code>BaseModel</code></p> <p>Base model for all Claude Code hook events.</p> <p>All events share these common fields from the hook input.</p>"},{"location":"api/events/#fasthooks.events.base.BaseEvent.session_id","title":"session_id  <code>instance-attribute</code>","text":"<pre><code>session_id: str\n</code></pre>"},{"location":"api/events/#fasthooks.events.base.BaseEvent.cwd","title":"cwd  <code>instance-attribute</code>","text":"<pre><code>cwd: str\n</code></pre>"},{"location":"api/events/#fasthooks.events.base.BaseEvent.permission_mode","title":"permission_mode  <code>instance-attribute</code>","text":"<pre><code>permission_mode: str\n</code></pre>"},{"location":"api/events/#fasthooks.events.base.BaseEvent.transcript_path","title":"transcript_path  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>transcript_path: str | None = None\n</code></pre>"},{"location":"api/events/#fasthooks.events.base.BaseEvent.hook_event_name","title":"hook_event_name  <code>instance-attribute</code>","text":"<pre><code>hook_event_name: str\n</code></pre>"},{"location":"api/events/#tool-events","title":"Tool Events","text":""},{"location":"api/events/#fasthooks.events.tools.ToolEvent","title":"ToolEvent","text":"<p>               Bases: <code>BaseEvent</code></p> <p>Base class for tool-related events (PreToolUse, PostToolUse).</p>"},{"location":"api/events/#fasthooks.events.tools.ToolEvent.tool_name","title":"tool_name  <code>instance-attribute</code>","text":"<pre><code>tool_name: str\n</code></pre>"},{"location":"api/events/#fasthooks.events.tools.ToolEvent.tool_input","title":"tool_input  <code>instance-attribute</code>","text":"<pre><code>tool_input: dict[str, Any]\n</code></pre>"},{"location":"api/events/#fasthooks.events.tools.ToolEvent.tool_use_id","title":"tool_use_id  <code>instance-attribute</code>","text":"<pre><code>tool_use_id: str\n</code></pre>"},{"location":"api/events/#fasthooks.events.tools.ToolEvent.tool_response","title":"tool_response  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>tool_response: dict[str, Any] | None = None\n</code></pre>"},{"location":"api/events/#fasthooks.events.tools.Bash","title":"Bash","text":"<p>               Bases: <code>ToolEvent</code></p> <p>Bash tool event with typed accessors.</p>"},{"location":"api/events/#fasthooks.events.tools.Bash.command","title":"command  <code>property</code>","text":"<pre><code>command: str\n</code></pre> <p>The bash command to execute.</p>"},{"location":"api/events/#fasthooks.events.tools.Bash.description","title":"description  <code>property</code>","text":"<pre><code>description: str | None\n</code></pre> <p>Optional description of the command.</p>"},{"location":"api/events/#fasthooks.events.tools.Bash.timeout","title":"timeout  <code>property</code>","text":"<pre><code>timeout: int | None\n</code></pre> <p>Optional timeout in milliseconds.</p>"},{"location":"api/events/#fasthooks.events.tools.Write","title":"Write","text":"<p>               Bases: <code>ToolEvent</code></p> <p>Write tool event.</p>"},{"location":"api/events/#fasthooks.events.tools.Write.file_path","title":"file_path  <code>property</code>","text":"<pre><code>file_path: str\n</code></pre> <p>Path to file being written.</p>"},{"location":"api/events/#fasthooks.events.tools.Write.content","title":"content  <code>property</code>","text":"<pre><code>content: str\n</code></pre> <p>Content to write.</p>"},{"location":"api/events/#fasthooks.events.tools.Edit","title":"Edit","text":"<p>               Bases: <code>ToolEvent</code></p> <p>Edit tool event.</p>"},{"location":"api/events/#fasthooks.events.tools.Edit.file_path","title":"file_path  <code>property</code>","text":"<pre><code>file_path: str\n</code></pre> <p>Path to file being edited.</p>"},{"location":"api/events/#fasthooks.events.tools.Edit.old_string","title":"old_string  <code>property</code>","text":"<pre><code>old_string: str\n</code></pre> <p>String to replace.</p>"},{"location":"api/events/#fasthooks.events.tools.Edit.new_string","title":"new_string  <code>property</code>","text":"<pre><code>new_string: str\n</code></pre> <p>Replacement string.</p>"},{"location":"api/events/#fasthooks.events.tools.Read","title":"Read","text":"<p>               Bases: <code>ToolEvent</code></p> <p>Read tool event.</p>"},{"location":"api/events/#fasthooks.events.tools.Read.file_path","title":"file_path  <code>property</code>","text":"<pre><code>file_path: str\n</code></pre> <p>Path to file being read.</p>"},{"location":"api/events/#fasthooks.events.tools.Read.offset","title":"offset  <code>property</code>","text":"<pre><code>offset: int | None\n</code></pre> <p>Optional line offset.</p>"},{"location":"api/events/#fasthooks.events.tools.Read.limit","title":"limit  <code>property</code>","text":"<pre><code>limit: int | None\n</code></pre> <p>Optional line limit.</p>"},{"location":"api/events/#fasthooks.events.tools.Grep","title":"Grep","text":"<p>               Bases: <code>ToolEvent</code></p> <p>Grep tool event.</p>"},{"location":"api/events/#fasthooks.events.tools.Grep.pattern","title":"pattern  <code>property</code>","text":"<pre><code>pattern: str\n</code></pre> <p>Search pattern.</p>"},{"location":"api/events/#fasthooks.events.tools.Grep.path","title":"path  <code>property</code>","text":"<pre><code>path: str | None\n</code></pre> <p>Path to search in.</p>"},{"location":"api/events/#fasthooks.events.tools.Glob","title":"Glob","text":"<p>               Bases: <code>ToolEvent</code></p> <p>Glob tool event.</p>"},{"location":"api/events/#fasthooks.events.tools.Glob.pattern","title":"pattern  <code>property</code>","text":"<pre><code>pattern: str\n</code></pre> <p>Glob pattern.</p>"},{"location":"api/events/#fasthooks.events.tools.Glob.path","title":"path  <code>property</code>","text":"<pre><code>path: str | None\n</code></pre> <p>Base path.</p>"},{"location":"api/events/#fasthooks.events.tools.Task","title":"Task","text":"<p>               Bases: <code>ToolEvent</code></p> <p>Task (subagent) tool event.</p>"},{"location":"api/events/#fasthooks.events.tools.Task.prompt","title":"prompt  <code>property</code>","text":"<pre><code>prompt: str\n</code></pre> <p>Task prompt.</p>"},{"location":"api/events/#fasthooks.events.tools.Task.description","title":"description  <code>property</code>","text":"<pre><code>description: str\n</code></pre> <p>Task description.</p>"},{"location":"api/events/#fasthooks.events.tools.WebSearch","title":"WebSearch","text":"<p>               Bases: <code>ToolEvent</code></p> <p>WebSearch tool event.</p>"},{"location":"api/events/#fasthooks.events.tools.WebSearch.query","title":"query  <code>property</code>","text":"<pre><code>query: str\n</code></pre> <p>Search query.</p>"},{"location":"api/events/#fasthooks.events.tools.WebFetch","title":"WebFetch","text":"<p>               Bases: <code>ToolEvent</code></p> <p>WebFetch tool event.</p>"},{"location":"api/events/#fasthooks.events.tools.WebFetch.url","title":"url  <code>property</code>","text":"<pre><code>url: str\n</code></pre> <p>URL to fetch.</p>"},{"location":"api/events/#fasthooks.events.tools.WebFetch.prompt","title":"prompt  <code>property</code>","text":"<pre><code>prompt: str\n</code></pre> <p>Prompt for processing.</p>"},{"location":"api/events/#lifecycle-events","title":"Lifecycle Events","text":""},{"location":"api/events/#fasthooks.events.lifecycle.Stop","title":"Stop","text":"<p>               Bases: <code>BaseEvent</code></p> <p>Stop event - main agent finished responding.</p>"},{"location":"api/events/#fasthooks.events.lifecycle.Stop.stop_hook_active","title":"stop_hook_active  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>stop_hook_active: bool = False\n</code></pre>"},{"location":"api/events/#fasthooks.events.lifecycle.SubagentStop","title":"SubagentStop","text":"<p>               Bases: <code>BaseEvent</code></p> <p>SubagentStop event - subagent finished responding.</p>"},{"location":"api/events/#fasthooks.events.lifecycle.SubagentStop.stop_hook_active","title":"stop_hook_active  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>stop_hook_active: bool = False\n</code></pre>"},{"location":"api/events/#fasthooks.events.lifecycle.SessionStart","title":"SessionStart","text":"<p>               Bases: <code>BaseEvent</code></p> <p>SessionStart event - session begins or resumes.</p>"},{"location":"api/events/#fasthooks.events.lifecycle.SessionStart.source","title":"source  <code>instance-attribute</code>","text":"<pre><code>source: str\n</code></pre>"},{"location":"api/events/#fasthooks.events.lifecycle.SessionEnd","title":"SessionEnd","text":"<p>               Bases: <code>BaseEvent</code></p> <p>SessionEnd event - session ends.</p>"},{"location":"api/events/#fasthooks.events.lifecycle.SessionEnd.reason","title":"reason  <code>instance-attribute</code>","text":"<pre><code>reason: str\n</code></pre>"},{"location":"api/events/#fasthooks.events.lifecycle.PreCompact","title":"PreCompact","text":"<p>               Bases: <code>BaseEvent</code></p> <p>PreCompact event - before context compaction.</p>"},{"location":"api/events/#fasthooks.events.lifecycle.PreCompact.trigger","title":"trigger  <code>instance-attribute</code>","text":"<pre><code>trigger: str\n</code></pre>"},{"location":"api/events/#fasthooks.events.lifecycle.PreCompact.custom_instructions","title":"custom_instructions  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>custom_instructions: str | None = None\n</code></pre>"},{"location":"api/events/#fasthooks.events.lifecycle.UserPromptSubmit","title":"UserPromptSubmit","text":"<p>               Bases: <code>BaseEvent</code></p> <p>UserPromptSubmit event - user submits a prompt.</p>"},{"location":"api/events/#fasthooks.events.lifecycle.UserPromptSubmit.prompt","title":"prompt  <code>instance-attribute</code>","text":"<pre><code>prompt: str\n</code></pre>"},{"location":"api/events/#fasthooks.events.lifecycle.Notification","title":"Notification","text":"<p>               Bases: <code>BaseEvent</code></p> <p>Notification event - notification sent.</p>"},{"location":"api/events/#fasthooks.events.lifecycle.Notification.message","title":"message  <code>instance-attribute</code>","text":"<pre><code>message: str\n</code></pre>"},{"location":"api/events/#fasthooks.events.lifecycle.Notification.notification_type","title":"notification_type  <code>instance-attribute</code>","text":"<pre><code>notification_type: str\n</code></pre>"},{"location":"api/responses/","title":"Responses","text":"<p>Response builders for hook handlers.</p>"},{"location":"api/responses/#response-functions","title":"Response Functions","text":""},{"location":"api/responses/#fasthooks.responses.allow","title":"allow","text":"<pre><code>allow(\n    *,\n    modify: dict[str, Any] | None = None,\n    message: str | None = None,\n) -&gt; HookResponse\n</code></pre> <p>Allow the action to proceed.</p> <p>Parameters:</p> Name Type Description Default <code>modify</code> <code>dict[str, Any] | None</code> <p>Optional dict to modify tool input before execution</p> <code>None</code> <code>message</code> <code>str | None</code> <p>Optional message shown to user</p> <code>None</code> <p>Returns:</p> Type Description <code>HookResponse</code> <p>HookResponse with approve decision</p>"},{"location":"api/responses/#fasthooks.responses.deny","title":"deny","text":"<pre><code>deny(\n    reason: str, *, interrupt: bool = False\n) -&gt; HookResponse\n</code></pre> <p>Deny/block the action.</p> <p>Parameters:</p> Name Type Description Default <code>reason</code> <code>str</code> <p>Explanation shown to Claude</p> required <code>interrupt</code> <code>bool</code> <p>If True, stops Claude entirely</p> <code>False</code> <p>Returns:</p> Type Description <code>HookResponse</code> <p>HookResponse with deny decision</p>"},{"location":"api/responses/#fasthooks.responses.block","title":"block","text":"<pre><code>block(reason: str) -&gt; HookResponse\n</code></pre> <p>Block Stop/SubagentStop - force Claude to continue.</p> <p>Parameters:</p> Name Type Description Default <code>reason</code> <code>str</code> <p>Explanation of what Claude should do</p> required <p>Returns:</p> Type Description <code>HookResponse</code> <p>HookResponse with block decision</p>"},{"location":"api/responses/#fasthooks.responses.approve_permission","title":"approve_permission","text":"<pre><code>approve_permission(\n    *, modify: dict[str, Any] | None = None\n) -&gt; PermissionHookResponse\n</code></pre> <p>Approve a permission request.</p> <p>Parameters:</p> Name Type Description Default <code>modify</code> <code>dict[str, Any] | None</code> <p>Optional dict to modify tool input before execution</p> <code>None</code> <p>Returns:</p> Type Description <code>PermissionHookResponse</code> <p>PermissionHookResponse with allow behavior</p>"},{"location":"api/responses/#fasthooks.responses.deny_permission","title":"deny_permission","text":"<pre><code>deny_permission(\n    message: str | None = None, *, interrupt: bool = False\n) -&gt; PermissionHookResponse\n</code></pre> <p>Deny a permission request.</p> <p>Parameters:</p> Name Type Description Default <code>message</code> <code>str | None</code> <p>Explanation shown to Claude</p> <code>None</code> <code>interrupt</code> <code>bool</code> <p>If True, stops Claude entirely</p> <code>False</code> <p>Returns:</p> Type Description <code>PermissionHookResponse</code> <p>PermissionHookResponse with deny behavior</p>"},{"location":"api/responses/#response-classes","title":"Response Classes","text":""},{"location":"api/responses/#fasthooks.responses.BaseHookResponse","title":"BaseHookResponse","text":"<p>               Bases: <code>ABC</code></p> <p>Abstract base class for hook responses.</p>"},{"location":"api/responses/#fasthooks.responses.BaseHookResponse.should_return","title":"should_return","text":"<pre><code>should_return() -&gt; bool\n</code></pre> <p>Whether this response should be returned (stop handler chain).</p> <p>Override in subclasses for custom behavior. Default: always return.</p>"},{"location":"api/responses/#fasthooks.responses.BaseHookResponse.to_json","title":"to_json  <code>abstractmethod</code>","text":"<pre><code>to_json() -&gt; str\n</code></pre> <p>Serialize to Claude Code expected JSON format.</p>"},{"location":"api/responses/#fasthooks.responses.HookResponse","title":"HookResponse  <code>dataclass</code>","text":"<p>               Bases: <code>BaseHookResponse</code></p> <p>Response from a hook handler.</p>"},{"location":"api/responses/#fasthooks.responses.HookResponse.decision","title":"decision  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>decision: str | None = None\n</code></pre>"},{"location":"api/responses/#fasthooks.responses.HookResponse.reason","title":"reason  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>reason: str | None = None\n</code></pre>"},{"location":"api/responses/#fasthooks.responses.HookResponse.message","title":"message  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>message: str | None = None\n</code></pre>"},{"location":"api/responses/#fasthooks.responses.HookResponse.interrupt","title":"interrupt  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>interrupt: bool = False\n</code></pre>"},{"location":"api/responses/#fasthooks.responses.HookResponse.to_json","title":"to_json","text":"<pre><code>to_json() -&gt; str\n</code></pre> <p>Serialize to Claude Code expected JSON format.</p>"},{"location":"api/tasks/","title":"Background Tasks","text":"<p>Background task system for async operations in hooks.</p>"},{"location":"api/tasks/#task-definition","title":"Task Definition","text":""},{"location":"api/tasks/#fasthooks.tasks.base.task","title":"task","text":"<pre><code>task(\n    func: Callable[..., Any] | None = None,\n    *,\n    priority: int = 0,\n    ttl: int = 300,\n    transform: Callable[[Any], Any] | None = None,\n) -&gt; Task | Callable[[Callable[..., Any]], Task]\n</code></pre> <p>Decorator to define a background task.</p> Usage <p>@task def simple_task(x: int) -&gt; int:     return x * 2</p> <p>@task(priority=2, ttl=600) def slow_task(query: str) -&gt; str:     return search_db(query)</p> <p>@task(transform=lambda r: f\"Result: {r}\") def formatted_task(x: int) -&gt; str:     return x * 2</p>"},{"location":"api/tasks/#fasthooks.tasks.base.Task","title":"Task  <code>dataclass</code>","text":"<p>A background task definition.</p> Usage <p>@task def my_task(x: int) -&gt; int:     return x * 2</p>"},{"location":"api/tasks/#fasthooks.tasks.base.Task--or-with-options","title":"Or with options","text":"<p>@task(priority=2, ttl=600) def slow_task(query: str) -&gt; str:     return search_db(query)</p>"},{"location":"api/tasks/#fasthooks.tasks.base.Task.func","title":"func  <code>instance-attribute</code>","text":"<pre><code>func: Callable[..., Any]\n</code></pre>"},{"location":"api/tasks/#fasthooks.tasks.base.Task.priority","title":"priority  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>priority: int = 0\n</code></pre>"},{"location":"api/tasks/#fasthooks.tasks.base.Task.ttl","title":"ttl  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>ttl: int = 300\n</code></pre>"},{"location":"api/tasks/#fasthooks.tasks.base.Task.transform","title":"transform  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>transform: Callable[[Any], Any] | None = None\n</code></pre>"},{"location":"api/tasks/#fasthooks.tasks.base.Task.name","title":"name  <code>property</code>","text":"<pre><code>name: str\n</code></pre> <p>Get task function name.</p>"},{"location":"api/tasks/#fasthooks.tasks.base.Task.__call__","title":"__call__","text":"<pre><code>__call__(*args: Any, **kwargs: Any) -&gt; Any\n</code></pre> <p>Call the underlying function directly (for testing).</p>"},{"location":"api/tasks/#fasthooks.tasks.base.TaskResult","title":"TaskResult  <code>dataclass</code>","text":"<p>Result of a background task execution.</p>"},{"location":"api/tasks/#fasthooks.tasks.base.TaskResult.id","title":"id  <code>instance-attribute</code>","text":"<pre><code>id: str\n</code></pre>"},{"location":"api/tasks/#fasthooks.tasks.base.TaskResult.session_id","title":"session_id  <code>instance-attribute</code>","text":"<pre><code>session_id: str\n</code></pre>"},{"location":"api/tasks/#fasthooks.tasks.base.TaskResult.key","title":"key  <code>instance-attribute</code>","text":"<pre><code>key: str\n</code></pre>"},{"location":"api/tasks/#fasthooks.tasks.base.TaskResult.status","title":"status  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>status: TaskStatus = PENDING\n</code></pre>"},{"location":"api/tasks/#fasthooks.tasks.base.TaskResult.value","title":"value  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>value: Any = None\n</code></pre>"},{"location":"api/tasks/#fasthooks.tasks.base.TaskResult.error","title":"error  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>error: Exception | None = None\n</code></pre>"},{"location":"api/tasks/#fasthooks.tasks.base.TaskResult.created_at","title":"created_at  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>created_at: float = field(default_factory=time)\n</code></pre>"},{"location":"api/tasks/#fasthooks.tasks.base.TaskResult.started_at","title":"started_at  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>started_at: float | None = None\n</code></pre>"},{"location":"api/tasks/#fasthooks.tasks.base.TaskResult.finished_at","title":"finished_at  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>finished_at: float | None = None\n</code></pre>"},{"location":"api/tasks/#fasthooks.tasks.base.TaskResult.ttl","title":"ttl  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>ttl: int = 300\n</code></pre>"},{"location":"api/tasks/#fasthooks.tasks.base.TaskResult.is_finished","title":"is_finished  <code>property</code>","text":"<pre><code>is_finished: bool\n</code></pre> <p>Check if task has completed (success or failure).</p>"},{"location":"api/tasks/#fasthooks.tasks.base.TaskResult.is_expired","title":"is_expired  <code>property</code>","text":"<pre><code>is_expired: bool\n</code></pre> <p>Check if task result has expired based on TTL.</p> <p>TTL is measured from finished_at (completion time) if available, otherwise from created_at. This ensures results remain available for the full TTL after completion, even for long-running tasks.</p>"},{"location":"api/tasks/#fasthooks.tasks.base.TaskStatus","title":"TaskStatus","text":"<p>               Bases: <code>str</code>, <code>Enum</code></p> <p>Status of a background task.</p>"},{"location":"api/tasks/#fasthooks.tasks.base.TaskStatus.PENDING","title":"PENDING  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>PENDING = 'pending'\n</code></pre>"},{"location":"api/tasks/#fasthooks.tasks.base.TaskStatus.RUNNING","title":"RUNNING  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>RUNNING = 'running'\n</code></pre>"},{"location":"api/tasks/#fasthooks.tasks.base.TaskStatus.COMPLETED","title":"COMPLETED  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>COMPLETED = 'completed'\n</code></pre>"},{"location":"api/tasks/#fasthooks.tasks.base.TaskStatus.FAILED","title":"FAILED  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>FAILED = 'failed'\n</code></pre>"},{"location":"api/tasks/#fasthooks.tasks.base.TaskStatus.CANCELLED","title":"CANCELLED  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>CANCELLED = 'cancelled'\n</code></pre>"},{"location":"api/tasks/#dependencies","title":"Dependencies","text":""},{"location":"api/tasks/#fasthooks.tasks.depends.Tasks","title":"Tasks","text":"<p>Unified background tasks dependency (enqueue + results).</p> <p>Injected into handlers to both enqueue background tasks and access results from previous hook calls.</p> <p>All operations are non-blocking: - <code>add()</code> submits to thread pool and returns immediately - <code>pop()</code>/<code>get()</code>/<code>has()</code> are dict lookups, return instantly - <code>wait*()</code> methods are async and yield while polling</p> <p>Keys are optional. If omitted, the task key defaults to the function name. For multiple concurrent calls to the same function, provide an explicit key to avoid collisions (later enqueues overwrite earlier results for the same key).</p> Usage <p>@app.on_prompt() def handler(event, tasks: Tasks):     if result := tasks.pop(memory_lookup):         return allow(message=f\"Found: {result}\")</p> <pre><code>tasks.add(memory_lookup, event.prompt)\nreturn allow()\n</code></pre>"},{"location":"api/tasks/#fasthooks.tasks.depends.Tasks.__init__","title":"__init__","text":"<pre><code>__init__(backend: BaseBackend, session_id: str)\n</code></pre>"},{"location":"api/tasks/#fasthooks.tasks.depends.Tasks.add","title":"add","text":"<pre><code>add(\n    func: Callable[..., Any] | Task,\n    *args: Any,\n    key: str | None = None,\n    ttl: int = 300,\n    **kwargs: Any,\n) -&gt; TaskResult\n</code></pre> <p>Add a task to be executed in the background.</p> <p>Parameters:</p> Name Type Description Default <code>func</code> <code>Callable[..., Any] | Task</code> <p>The function or Task to execute</p> required <code>*args</code> <code>Any</code> <p>Positional arguments for the function</p> <code>()</code> <code>key</code> <code>str | None</code> <p>Optional unique key (defaults to function name)</p> <code>None</code> <code>ttl</code> <code>int</code> <p>Time-to-live in seconds for the result (default 300)</p> <code>300</code> <code>**kwargs</code> <code>Any</code> <p>Keyword arguments for the function</p> <code>{}</code> <p>Returns:</p> Type Description <code>TaskResult</code> <p>TaskResult with status 'pending'</p>"},{"location":"api/tasks/#fasthooks.tasks.depends.Tasks.cancel","title":"cancel","text":"<pre><code>cancel(key: str | Callable[..., Any] | Task) -&gt; bool\n</code></pre> <p>Cancel a pending/running task by key.</p>"},{"location":"api/tasks/#fasthooks.tasks.depends.Tasks.cancel_all","title":"cancel_all","text":"<pre><code>cancel_all() -&gt; int\n</code></pre> <p>Cancel all tasks for this session. Returns count cancelled.</p>"},{"location":"api/tasks/#fasthooks.tasks.depends.Tasks.get","title":"get","text":"<pre><code>get(\n    key: str | Callable[..., Any] | Task,\n) -&gt; TaskResult | None\n</code></pre> <p>Get a task result without removing it.</p>"},{"location":"api/tasks/#fasthooks.tasks.depends.Tasks.pop","title":"pop","text":"<pre><code>pop(key: str | Callable[..., Any] | Task) -&gt; Any | None\n</code></pre> <p>Pop a completed result value, removing it from storage.</p> <p>Returns None if task not found or not yet completed.</p>"},{"location":"api/tasks/#fasthooks.tasks.depends.Tasks.pop_all","title":"pop_all","text":"<pre><code>pop_all() -&gt; list[Any]\n</code></pre> <p>Pop all completed results for this session.</p>"},{"location":"api/tasks/#fasthooks.tasks.depends.Tasks.pop_errors","title":"pop_errors","text":"<pre><code>pop_errors() -&gt; list[tuple[str, Exception]]\n</code></pre> <p>Pop all failed results, returning (key, error) pairs.</p>"},{"location":"api/tasks/#fasthooks.tasks.depends.Tasks.has","title":"has","text":"<pre><code>has(\n    key: str | Callable[..., Any] | Task | None = None,\n) -&gt; bool\n</code></pre> <p>Check if there are completed results.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>str | Callable[..., Any] | Task | None</code> <p>Specific task key to check, or None to check any</p> <code>None</code>"},{"location":"api/tasks/#fasthooks.tasks.depends.Tasks.wait","title":"wait  <code>async</code>","text":"<pre><code>wait(\n    key: str | Callable[..., Any] | Task,\n    timeout: float = 30.0,\n) -&gt; Any | None\n</code></pre> <p>Wait for a specific task to complete.</p>"},{"location":"api/tasks/#fasthooks.tasks.depends.Tasks.wait_all","title":"wait_all  <code>async</code>","text":"<pre><code>wait_all(\n    keys: list[str | Callable[..., Any] | Task],\n    timeout: float = 30.0,\n) -&gt; dict[str, Any]\n</code></pre> <p>Wait for multiple tasks to complete. Returns dict of key -&gt; value.</p>"},{"location":"api/tasks/#fasthooks.tasks.depends.Tasks.wait_any","title":"wait_any  <code>async</code>","text":"<pre><code>wait_any(\n    keys: list[str | Callable[..., Any] | Task],\n    timeout: float = 30.0,\n) -&gt; tuple[str, Any] | None\n</code></pre> <p>Wait for any task to complete. Returns (key, value) or None.</p>"},{"location":"api/tasks/#fasthooks.tasks.depends.BackgroundTasks","title":"BackgroundTasks","text":"<p>FastAPI-style task enqueueing dependency.</p> <p>Injected into handlers to allow adding background tasks.</p> Usage <p>@app.pre_tool(\"Write\") def on_write(event, tasks: BackgroundTasks):     tasks.add(review_code, event.content, key=\"review\")     return allow()</p>"},{"location":"api/tasks/#fasthooks.tasks.depends.BackgroundTasks.__init__","title":"__init__","text":"<pre><code>__init__(backend: BaseBackend, session_id: str)\n</code></pre>"},{"location":"api/tasks/#fasthooks.tasks.depends.BackgroundTasks.add","title":"add","text":"<pre><code>add(\n    func: Callable[..., Any] | Task,\n    *args: Any,\n    key: str,\n    ttl: int = 300,\n    **kwargs: Any,\n) -&gt; TaskResult\n</code></pre> <p>Add a task to be executed in the background.</p> <p>Parameters:</p> Name Type Description Default <code>func</code> <code>Callable[..., Any] | Task</code> <p>The function or Task to execute</p> required <code>*args</code> <code>Any</code> <p>Positional arguments for the function</p> <code>()</code> <code>key</code> <code>str</code> <p>Unique key for this task (used to retrieve results)</p> required <code>ttl</code> <code>int</code> <p>Time-to-live in seconds for the result (default 300)</p> <code>300</code> <code>**kwargs</code> <code>Any</code> <p>Keyword arguments for the function</p> <code>{}</code> <p>Returns:</p> Type Description <code>TaskResult</code> <p>TaskResult with status 'pending'</p>"},{"location":"api/tasks/#fasthooks.tasks.depends.BackgroundTasks.cancel","title":"cancel","text":"<pre><code>cancel(key: str) -&gt; bool\n</code></pre> <p>Cancel a pending/running task by key.</p>"},{"location":"api/tasks/#fasthooks.tasks.depends.BackgroundTasks.cancel_all","title":"cancel_all","text":"<pre><code>cancel_all() -&gt; int\n</code></pre> <p>Cancel all tasks for this session. Returns count cancelled.</p>"},{"location":"api/tasks/#fasthooks.tasks.depends.PendingResults","title":"PendingResults","text":"<p>Access to completed background task results.</p> <p>Injected into handlers to retrieve results from previous tasks.</p> Usage <p>@app.on_prompt() def check_memory(event, pending: PendingResults):     if result := pending.pop(\"memory\"):         return allow(message=f\"Found: {result}\")     return allow()</p>"},{"location":"api/tasks/#fasthooks.tasks.depends.PendingResults.__init__","title":"__init__","text":"<pre><code>__init__(backend: BaseBackend, session_id: str)\n</code></pre>"},{"location":"api/tasks/#fasthooks.tasks.depends.PendingResults.get","title":"get","text":"<pre><code>get(key: str) -&gt; TaskResult | None\n</code></pre> <p>Get a task result without removing it.</p>"},{"location":"api/tasks/#fasthooks.tasks.depends.PendingResults.pop","title":"pop","text":"<pre><code>pop(key: str) -&gt; Any | None\n</code></pre> <p>Pop a completed result value, removing it from storage.</p> <p>Returns None if task not found or not yet completed.</p>"},{"location":"api/tasks/#fasthooks.tasks.depends.PendingResults.pop_all","title":"pop_all","text":"<pre><code>pop_all() -&gt; list[Any]\n</code></pre> <p>Pop all completed results for this session.</p>"},{"location":"api/tasks/#fasthooks.tasks.depends.PendingResults.pop_errors","title":"pop_errors","text":"<pre><code>pop_errors() -&gt; list[tuple[str, Exception]]\n</code></pre> <p>Pop all failed results, returning (key, error) pairs.</p>"},{"location":"api/tasks/#fasthooks.tasks.depends.PendingResults.has","title":"has","text":"<pre><code>has(key: str | None = None) -&gt; bool\n</code></pre> <p>Check if there are completed results.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>str | None</code> <p>Specific task key to check, or None to check any</p> <code>None</code>"},{"location":"api/tasks/#fasthooks.tasks.depends.PendingResults.wait","title":"wait  <code>async</code>","text":"<pre><code>wait(key: str, timeout: float = 30.0) -&gt; Any | None\n</code></pre> <p>Wait for a specific task to complete.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>str</code> <p>Task key to wait for</p> required <code>timeout</code> <code>float</code> <p>Maximum seconds to wait</p> <code>30.0</code> <p>Returns:</p> Type Description <code>Any | None</code> <p>Task result value, or None if timeout/failed/cancelled</p>"},{"location":"api/tasks/#fasthooks.tasks.depends.PendingResults.wait_all","title":"wait_all  <code>async</code>","text":"<pre><code>wait_all(\n    keys: list[str], timeout: float = 30.0\n) -&gt; dict[str, Any]\n</code></pre> <p>Wait for multiple tasks to complete.</p> <p>Parameters:</p> Name Type Description Default <code>keys</code> <code>list[str]</code> <p>List of task keys to wait for</p> required <code>timeout</code> <code>float</code> <p>Maximum seconds to wait</p> <code>30.0</code> <p>Returns:</p> Type Description <code>dict[str, Any]</code> <p>Dict of key -&gt; value for completed tasks</p>"},{"location":"api/tasks/#fasthooks.tasks.depends.PendingResults.wait_any","title":"wait_any  <code>async</code>","text":"<pre><code>wait_any(\n    keys: list[str], timeout: float = 30.0\n) -&gt; tuple[str, Any] | None\n</code></pre> <p>Wait for any task to complete.</p> <p>Parameters:</p> Name Type Description Default <code>keys</code> <code>list[str]</code> <p>List of task keys to wait for</p> required <code>timeout</code> <code>float</code> <p>Maximum seconds to wait</p> <code>30.0</code> <p>Returns:</p> Type Description <code>tuple[str, Any] | None</code> <p>(key, value) tuple for first completed task, or None</p>"},{"location":"api/tasks/#backends","title":"Backends","text":""},{"location":"api/tasks/#fasthooks.tasks.backend.BaseBackend","title":"BaseBackend","text":"<p>               Bases: <code>ABC</code></p> <p>Abstract base class for task backends.</p>"},{"location":"api/tasks/#fasthooks.tasks.backend.BaseBackend.enqueue","title":"enqueue  <code>abstractmethod</code>","text":"<pre><code>enqueue(\n    task: Task,\n    args: tuple[Any, ...],\n    kwargs: dict[str, Any],\n    *,\n    session_id: str,\n    key: str,\n) -&gt; TaskResult\n</code></pre> <p>Enqueue a task for execution.</p>"},{"location":"api/tasks/#fasthooks.tasks.backend.BaseBackend.get","title":"get  <code>abstractmethod</code>","text":"<pre><code>get(session_id: str, key: str) -&gt; TaskResult | None\n</code></pre> <p>Get a task result by session and key.</p>"},{"location":"api/tasks/#fasthooks.tasks.backend.BaseBackend.pop","title":"pop  <code>abstractmethod</code>","text":"<pre><code>pop(session_id: str, key: str) -&gt; Any | None\n</code></pre> <p>Pop a completed result value, removing it from storage.</p>"},{"location":"api/tasks/#fasthooks.tasks.backend.BaseBackend.pop_all","title":"pop_all  <code>abstractmethod</code>","text":"<pre><code>pop_all(session_id: str) -&gt; list[Any]\n</code></pre> <p>Pop all completed results for a session.</p>"},{"location":"api/tasks/#fasthooks.tasks.backend.BaseBackend.cancel","title":"cancel  <code>abstractmethod</code>","text":"<pre><code>cancel(session_id: str, key: str) -&gt; bool\n</code></pre> <p>Cancel a pending/running task.</p>"},{"location":"api/tasks/#fasthooks.tasks.backend.BaseBackend.cancel_all","title":"cancel_all  <code>abstractmethod</code>","text":"<pre><code>cancel_all(session_id: str) -&gt; int\n</code></pre> <p>Cancel all tasks for a session. Returns count cancelled.</p>"},{"location":"api/tasks/#fasthooks.tasks.backend.BaseBackend.pop_errors","title":"pop_errors  <code>abstractmethod</code>","text":"<pre><code>pop_errors(session_id: str) -&gt; list[tuple[str, Exception]]\n</code></pre> <p>Pop all failed results for a session, returning (key, error) pairs.</p>"},{"location":"api/tasks/#fasthooks.tasks.backend.BaseBackend.has","title":"has  <code>abstractmethod</code>","text":"<pre><code>has(session_id: str, key: str | None = None) -&gt; bool\n</code></pre> <p>Check if there are any completed results.</p>"},{"location":"api/tasks/#fasthooks.tasks.backend.BaseBackend.wait","title":"wait  <code>abstractmethod</code> <code>async</code>","text":"<pre><code>wait(\n    session_id: str, key: str, timeout: float = 30.0\n) -&gt; Any | None\n</code></pre> <p>Wait for a specific task to complete.</p>"},{"location":"api/tasks/#fasthooks.tasks.backend.BaseBackend.wait_all","title":"wait_all  <code>abstractmethod</code> <code>async</code>","text":"<pre><code>wait_all(\n    session_id: str, keys: list[str], timeout: float = 30.0\n) -&gt; dict[str, Any]\n</code></pre> <p>Wait for multiple tasks to complete. Returns dict of key -&gt; value.</p>"},{"location":"api/tasks/#fasthooks.tasks.backend.BaseBackend.wait_any","title":"wait_any  <code>abstractmethod</code> <code>async</code>","text":"<pre><code>wait_any(\n    session_id: str, keys: list[str], timeout: float = 30.0\n) -&gt; tuple[str, Any] | None\n</code></pre> <p>Wait for any task to complete. Returns (key, value) or None.</p>"},{"location":"api/tasks/#fasthooks.tasks.backend.InMemoryBackend","title":"InMemoryBackend","text":"<p>               Bases: <code>BaseBackend</code></p> <p>In-memory task backend using ThreadPoolExecutor.</p> <p>Tasks are executed in a thread pool and results are stored in memory. Results are automatically cleaned up when expired (lazy cleanup on access).</p>"},{"location":"api/tasks/#fasthooks.tasks.backend.InMemoryBackend.__init__","title":"__init__","text":"<pre><code>__init__(max_workers: int = 4)\n</code></pre>"},{"location":"api/tasks/#fasthooks.tasks.backend.InMemoryBackend.enqueue","title":"enqueue","text":"<pre><code>enqueue(\n    task: Task,\n    args: tuple[Any, ...],\n    kwargs: dict[str, Any],\n    *,\n    session_id: str,\n    key: str,\n) -&gt; TaskResult\n</code></pre> <p>Enqueue a task for background execution.</p>"},{"location":"api/tasks/#fasthooks.tasks.backend.InMemoryBackend.get","title":"get","text":"<pre><code>get(session_id: str, key: str) -&gt; TaskResult | None\n</code></pre> <p>Get a task result by session and key.</p>"},{"location":"api/tasks/#fasthooks.tasks.backend.InMemoryBackend.pop","title":"pop","text":"<pre><code>pop(session_id: str, key: str) -&gt; Any | None\n</code></pre> <p>Pop a completed result value, removing it from storage.</p>"},{"location":"api/tasks/#fasthooks.tasks.backend.InMemoryBackend.pop_all","title":"pop_all","text":"<pre><code>pop_all(session_id: str) -&gt; list[Any]\n</code></pre> <p>Pop all completed results for a session.</p>"},{"location":"api/tasks/#fasthooks.tasks.backend.InMemoryBackend.shutdown","title":"shutdown","text":"<pre><code>shutdown(wait: bool = True) -&gt; None\n</code></pre> <p>Shutdown the thread pool.</p>"},{"location":"api/tasks/#testing","title":"Testing","text":""},{"location":"api/tasks/#fasthooks.tasks.testing.ImmediateBackend","title":"ImmediateBackend","text":"<p>               Bases: <code>BaseBackend</code></p> <p>Backend that executes tasks immediately (synchronously).</p> <p>Useful for testing when you want tasks to complete before assertions. Tracks full lifecycle (status transitions, timestamps).</p> Example <p>backend = ImmediateBackend() app = HookApp(task_backend=backend)</p>"},{"location":"api/tasks/#fasthooks.tasks.testing.ImmediateBackend--tasks-complete-immediately","title":"Tasks complete immediately","text":"<p>client = TestClient(app) response = client.send(MockEvent.bash(command=\"ls\"))</p>"},{"location":"api/tasks/#fasthooks.tasks.testing.ImmediateBackend--results-are-immediately-available","title":"Results are immediately available","text":"<p>assert backend.get(\"session\", \"key\").status == TaskStatus.COMPLETED</p>"},{"location":"api/tasks/#fasthooks.tasks.testing.ImmediateBackend.enqueue","title":"enqueue","text":"<pre><code>enqueue(\n    task: Task,\n    args: tuple[Any, ...],\n    kwargs: dict[str, Any],\n    *,\n    session_id: str,\n    key: str,\n) -&gt; TaskResult\n</code></pre> <p>Execute task immediately (synchronous).</p>"},{"location":"api/testing/","title":"Testing Utilities","text":"<p>Utilities for testing hook handlers.</p>"},{"location":"api/testing/#mockevent","title":"MockEvent","text":"<p>Factory for creating test events.</p>"},{"location":"api/testing/#fasthooks.testing.mocks.MockEvent","title":"MockEvent","text":"<p>Factory for creating test events.</p> Example <p>event = MockEvent.bash(command=\"ls -la\") result = my_handler(event) assert result.decision != \"deny\"</p>"},{"location":"api/testing/#fasthooks.testing.mocks.MockEvent.bash","title":"bash  <code>staticmethod</code>","text":"<pre><code>bash(\n    command: str,\n    *,\n    description: str | None = None,\n    timeout: int | None = None,\n    session_id: str = \"test-session\",\n    cwd: str = \"/workspace\",\n) -&gt; Bash\n</code></pre> <p>Create a Bash PreToolUse event.</p>"},{"location":"api/testing/#fasthooks.testing.mocks.MockEvent.write","title":"write  <code>staticmethod</code>","text":"<pre><code>write(\n    file_path: str,\n    content: str = \"\",\n    *,\n    session_id: str = \"test-session\",\n    cwd: str = \"/workspace\",\n) -&gt; Write\n</code></pre> <p>Create a Write PreToolUse event.</p>"},{"location":"api/testing/#fasthooks.testing.mocks.MockEvent.edit","title":"edit  <code>staticmethod</code>","text":"<pre><code>edit(\n    file_path: str,\n    old_string: str,\n    new_string: str,\n    *,\n    session_id: str = \"test-session\",\n    cwd: str = \"/workspace\",\n) -&gt; Edit\n</code></pre> <p>Create an Edit PreToolUse event.</p>"},{"location":"api/testing/#fasthooks.testing.mocks.MockEvent.read","title":"read  <code>staticmethod</code>","text":"<pre><code>read(\n    file_path: str,\n    *,\n    session_id: str = \"test-session\",\n    cwd: str = \"/workspace\",\n) -&gt; Read\n</code></pre> <p>Create a Read PreToolUse event.</p>"},{"location":"api/testing/#fasthooks.testing.mocks.MockEvent.grep","title":"grep  <code>staticmethod</code>","text":"<pre><code>grep(\n    pattern: str,\n    *,\n    path: str | None = None,\n    glob: str | None = None,\n    output_mode: str | None = None,\n    session_id: str = \"test-session\",\n    cwd: str = \"/workspace\",\n) -&gt; Grep\n</code></pre> <p>Create a Grep PreToolUse event.</p>"},{"location":"api/testing/#fasthooks.testing.mocks.MockEvent.glob","title":"glob  <code>staticmethod</code>","text":"<pre><code>glob(\n    pattern: str,\n    *,\n    path: str | None = None,\n    session_id: str = \"test-session\",\n    cwd: str = \"/workspace\",\n) -&gt; Glob\n</code></pre> <p>Create a Glob PreToolUse event.</p>"},{"location":"api/testing/#fasthooks.testing.mocks.MockEvent.task","title":"task  <code>staticmethod</code>","text":"<pre><code>task(\n    prompt: str,\n    *,\n    description: str = \"Test task\",\n    subagent_type: str | None = None,\n    model: str | None = None,\n    session_id: str = \"test-session\",\n    cwd: str = \"/workspace\",\n) -&gt; Task\n</code></pre> <p>Create a Task PreToolUse event.</p>"},{"location":"api/testing/#fasthooks.testing.mocks.MockEvent.web_search","title":"web_search  <code>staticmethod</code>","text":"<pre><code>web_search(\n    query: str,\n    *,\n    session_id: str = \"test-session\",\n    cwd: str = \"/workspace\",\n) -&gt; WebSearch\n</code></pre> <p>Create a WebSearch PreToolUse event.</p>"},{"location":"api/testing/#fasthooks.testing.mocks.MockEvent.web_fetch","title":"web_fetch  <code>staticmethod</code>","text":"<pre><code>web_fetch(\n    url: str,\n    prompt: str = \"\",\n    *,\n    session_id: str = \"test-session\",\n    cwd: str = \"/workspace\",\n) -&gt; WebFetch\n</code></pre> <p>Create a WebFetch PreToolUse event.</p>"},{"location":"api/testing/#fasthooks.testing.mocks.MockEvent.stop","title":"stop  <code>staticmethod</code>","text":"<pre><code>stop(\n    *,\n    stop_hook_active: bool = False,\n    session_id: str = \"test-session\",\n    cwd: str = \"/workspace\",\n) -&gt; Stop\n</code></pre> <p>Create a Stop event.</p>"},{"location":"api/testing/#fasthooks.testing.mocks.MockEvent.subagent_stop","title":"subagent_stop  <code>staticmethod</code>","text":"<pre><code>subagent_stop(\n    *,\n    stop_hook_active: bool = False,\n    session_id: str = \"test-session\",\n    cwd: str = \"/workspace\",\n) -&gt; SubagentStop\n</code></pre> <p>Create a SubagentStop event.</p>"},{"location":"api/testing/#fasthooks.testing.mocks.MockEvent.session_start","title":"session_start  <code>staticmethod</code>","text":"<pre><code>session_start(\n    source: str = \"startup\",\n    *,\n    session_id: str = \"test-session\",\n    cwd: str = \"/workspace\",\n) -&gt; SessionStart\n</code></pre> <p>Create a SessionStart event.</p>"},{"location":"api/testing/#fasthooks.testing.mocks.MockEvent.session_end","title":"session_end  <code>staticmethod</code>","text":"<pre><code>session_end(\n    reason: str = \"user_exit\",\n    *,\n    session_id: str = \"test-session\",\n    cwd: str = \"/workspace\",\n) -&gt; SessionEnd\n</code></pre> <p>Create a SessionEnd event.</p>"},{"location":"api/testing/#fasthooks.testing.mocks.MockEvent.pre_compact","title":"pre_compact  <code>staticmethod</code>","text":"<pre><code>pre_compact(\n    trigger: str = \"manual\",\n    *,\n    session_id: str = \"test-session\",\n    cwd: str = \"/workspace\",\n) -&gt; PreCompact\n</code></pre> <p>Create a PreCompact event.</p>"},{"location":"api/testing/#fasthooks.testing.mocks.MockEvent.user_prompt","title":"user_prompt  <code>staticmethod</code>","text":"<pre><code>user_prompt(\n    prompt: str,\n    *,\n    session_id: str = \"test-session\",\n    cwd: str = \"/workspace\",\n) -&gt; UserPromptSubmit\n</code></pre> <p>Create a UserPromptSubmit event.</p>"},{"location":"api/testing/#fasthooks.testing.mocks.MockEvent.notification","title":"notification  <code>staticmethod</code>","text":"<pre><code>notification(\n    message: str,\n    notification_type: str = \"info\",\n    *,\n    session_id: str = \"test-session\",\n    cwd: str = \"/workspace\",\n) -&gt; Notification\n</code></pre> <p>Create a Notification event.</p>"},{"location":"api/testing/#fasthooks.testing.mocks.MockEvent.permission_bash","title":"permission_bash  <code>staticmethod</code>","text":"<pre><code>permission_bash(\n    command: str,\n    *,\n    description: str | None = None,\n    session_id: str = \"test-session\",\n    cwd: str = \"/workspace\",\n) -&gt; Bash\n</code></pre> <p>Create a Bash PermissionRequest event.</p>"},{"location":"api/testing/#fasthooks.testing.mocks.MockEvent.permission_write","title":"permission_write  <code>staticmethod</code>","text":"<pre><code>permission_write(\n    file_path: str,\n    content: str = \"\",\n    *,\n    session_id: str = \"test-session\",\n    cwd: str = \"/workspace\",\n) -&gt; Write\n</code></pre> <p>Create a Write PermissionRequest event.</p>"},{"location":"api/testing/#fasthooks.testing.mocks.MockEvent.permission_edit","title":"permission_edit  <code>staticmethod</code>","text":"<pre><code>permission_edit(\n    file_path: str,\n    old_string: str,\n    new_string: str,\n    *,\n    session_id: str = \"test-session\",\n    cwd: str = \"/workspace\",\n) -&gt; Edit\n</code></pre> <p>Create an Edit PermissionRequest event.</p>"},{"location":"api/testing/#testclient","title":"TestClient","text":"<p>Client for testing hook applications.</p>"},{"location":"api/testing/#fasthooks.testing.client.TestClient","title":"TestClient","text":"<p>Test client for invoking hook handlers.</p> <p>Allows testing hooks without stdin/stdout plumbing.</p> Example <p>app = HookApp()</p> <p>@app.pre_tool(\"Bash\") def handler(event):     return allow()</p> <p>client = TestClient(app) response = client.send(MockEvent.bash(command=\"ls\")) assert response is None  # allowed</p>"},{"location":"api/testing/#fasthooks.testing.client.TestClient.__init__","title":"__init__","text":"<pre><code>__init__(app: HookApp)\n</code></pre> <p>Initialize TestClient.</p> <p>Parameters:</p> Name Type Description Default <code>app</code> <code>HookApp</code> <p>HookApp to test</p> required"},{"location":"api/testing/#fasthooks.testing.client.TestClient.send","title":"send","text":"<pre><code>send(event: BaseEvent) -&gt; BaseHookResponse | None\n</code></pre> <p>Send an event to the app and return the response.</p> <p>Parameters:</p> Name Type Description Default <code>event</code> <code>BaseEvent</code> <p>Typed event (from MockEvent or manual)</p> required <p>Returns:</p> Type Description <code>BaseHookResponse | None</code> <p>BaseHookResponse if actionable, None if pass-through</p>"},{"location":"api/transcript/","title":"Transcript API Reference","text":"<p>Rich transcript modeling for context engineering.</p>"},{"location":"api/transcript/#transcript","title":"Transcript","text":"<p>Main class for loading and manipulating transcripts.</p> <pre><code>from fasthooks.transcript import Transcript\n</code></pre>"},{"location":"api/transcript/#constructor","title":"Constructor","text":"<pre><code>Transcript(\n    path: str | Path | None = None,\n    auto_load: bool = True,\n    validate: Literal[\"strict\", \"warn\", \"none\"] = \"warn\",\n    include_archived: bool = False,\n    include_meta: bool = False,\n)\n</code></pre> Parameter Description <code>path</code> Path to transcript JSONL file <code>auto_load</code> Load file immediately (default True) <code>validate</code> Unknown block handling: strict=error, warn=warning, none=silent <code>include_archived</code> Include pre-compaction entries in views <code>include_meta</code> Include system meta entries in views"},{"location":"api/transcript/#properties","title":"Properties","text":"Property Type Description <code>entries</code> <code>list[TranscriptEntry]</code> Current context window entries <code>archived</code> <code>list[TranscriptEntry]</code> Pre-compaction entries <code>all_entries</code> <code>list[TranscriptEntry]</code> archived + entries <code>user_messages</code> <code>list[UserMessage]</code> User message entries <code>assistant_messages</code> <code>list[AssistantMessage]</code> Assistant message entries <code>tool_uses</code> <code>list[ToolUseBlock]</code> All tool use blocks <code>tool_results</code> <code>list[ToolResultBlock]</code> All tool result blocks <code>errors</code> <code>list[ToolResultBlock]</code> Tool results with is_error=True <code>turns</code> <code>list[Turn]</code> Entries grouped by requestId <code>compact_boundaries</code> <code>list[CompactBoundary]</code> Compaction markers <code>stats</code> <code>TranscriptStats</code> Aggregated statistics"},{"location":"api/transcript/#crud-methods","title":"CRUD Methods","text":"<pre><code># Insert\ntranscript.insert(index: int, entry: Entry) -&gt; None\ntranscript.append(entry: Entry) -&gt; None\n\n# Remove\ntranscript.remove(entry: Entry, relink: bool = True) -&gt; None\ntranscript.remove_tree(entry: Entry) -&gt; list[Entry]\n\n# Replace\ntranscript.replace(old: Entry, new: Entry) -&gt; None\n\n# Persistence\ntranscript.load() -&gt; None\ntranscript.save() -&gt; None\n\n# Batch operations\nwith transcript.batch():\n    # Auto-commit on success, rollback on exception\n    ...\n</code></pre>"},{"location":"api/transcript/#query-methods","title":"Query Methods","text":"<pre><code>transcript.query(\n    include_archived: bool | None = None,\n    include_meta: bool | None = None,\n) -&gt; TranscriptQuery\n</code></pre>"},{"location":"api/transcript/#lookup-methods","title":"Lookup Methods","text":"<pre><code>transcript.find_by_uuid(uuid: str) -&gt; Entry | None\ntranscript.find_tool_use(tool_use_id: str) -&gt; ToolUseBlock | None\ntranscript.find_tool_result(tool_use_id: str) -&gt; ToolResultBlock | None\ntranscript.find_snapshot(message_id: str) -&gt; FileHistorySnapshot | None\ntranscript.get_parent(entry: Entry) -&gt; Entry | None\ntranscript.get_children(entry: Entry) -&gt; list[Entry]\ntranscript.get_logical_parent(entry: Entry) -&gt; Entry | None\n</code></pre>"},{"location":"api/transcript/#export-methods","title":"Export Methods","text":"<pre><code># To string\ntranscript.to_markdown(**kwargs) -&gt; str\ntranscript.to_html(**kwargs) -&gt; str\ntranscript.to_json(indent: int = 2) -&gt; str\ntranscript.to_jsonl() -&gt; str\n\n# To file\ntranscript.to_file(\n    path: str | Path,\n    format: Literal[\"md\", \"html\", \"json\", \"jsonl\"] = \"md\",\n    **kwargs\n) -&gt; None\n</code></pre>"},{"location":"api/transcript/#transcriptquery","title":"TranscriptQuery","text":"<p>Fluent query builder for filtering entries.</p> <pre><code>query = transcript.query()\n</code></pre>"},{"location":"api/transcript/#type-filters","title":"Type Filters","text":"<pre><code>query.users() -&gt; TranscriptQuery\nquery.assistants() -&gt; TranscriptQuery\nquery.system() -&gt; TranscriptQuery\nquery.with_tools() -&gt; TranscriptQuery\nquery.with_errors() -&gt; TranscriptQuery\nquery.with_thinking() -&gt; TranscriptQuery\n</code></pre>"},{"location":"api/transcript/#filtering","title":"Filtering","text":"<pre><code>query.filter(**kwargs) -&gt; TranscriptQuery\nquery.where(predicate: Callable) -&gt; TranscriptQuery\nquery.exclude(**kwargs) -&gt; TranscriptQuery\n</code></pre> <p>Supported lookups:</p> Lookup Example Description <code>exact</code> <code>filter(type=\"user\")</code> Exact match (default) <code>contains</code> <code>filter(text__contains=\"error\")</code> Substring <code>startswith</code> <code>filter(uuid__startswith=\"abc\")</code> Prefix <code>endswith</code> <code>filter(text__endswith=\"!\")</code> Suffix <code>regex</code> <code>filter(text__regex=r\"\\d+\")</code> Regex match <code>in</code> <code>filter(type__in=[\"user\", \"assistant\"])</code> In list <code>gt</code> <code>filter(timestamp__gt=datetime(...))</code> Greater than <code>gte</code> <code>filter(timestamp__gte=datetime(...))</code> Greater or equal <code>lt</code> <code>filter(timestamp__lt=datetime(...))</code> Less than <code>lte</code> <code>filter(timestamp__lte=datetime(...))</code> Less or equal <code>isnull</code> <code>filter(parent_uuid__isnull=True)</code> Is None"},{"location":"api/transcript/#time-filters","title":"Time Filters","text":"<pre><code>query.since(ts: datetime | str) -&gt; TranscriptQuery\nquery.until(ts: datetime | str) -&gt; TranscriptQuery\n</code></pre>"},{"location":"api/transcript/#ordering","title":"Ordering","text":"<pre><code>query.order_by(*fields: str) -&gt; TranscriptQuery\n# Prefix with - for descending: order_by(\"-timestamp\")\n</code></pre>"},{"location":"api/transcript/#pagination","title":"Pagination","text":"<pre><code>query.limit(n: int) -&gt; TranscriptQuery\nquery.offset(n: int) -&gt; TranscriptQuery\n</code></pre>"},{"location":"api/transcript/#terminals","title":"Terminals","text":"<pre><code>query.all() -&gt; list[TranscriptEntry]\nquery.first() -&gt; TranscriptEntry | None\nquery.last() -&gt; TranscriptEntry | None\nquery.one() -&gt; TranscriptEntry  # Raises if 0 or &gt;1 results\nquery.count() -&gt; int\nquery.exists() -&gt; bool\n</code></pre>"},{"location":"api/transcript/#entry-types","title":"Entry Types","text":""},{"location":"api/transcript/#entry-base","title":"Entry (Base)","text":"<pre><code>class Entry:\n    type: str\n    uuid: str\n    parent_uuid: str | None\n    timestamp: datetime | None\n    session_id: str\n    cwd: str\n    version: str\n    git_branch: str\n    is_sidechain: bool\n    is_synthetic: bool\n</code></pre>"},{"location":"api/transcript/#usermessage","title":"UserMessage","text":"<pre><code>class UserMessage(Entry):\n    type: Literal[\"user\"] = \"user\"\n\n    # Properties\n    content: str | list[ToolResultBlock]\n    text: str  # Empty if tool result\n    is_tool_result: bool\n    tool_results: list[ToolResultBlock]\n\n    # Factory\n    @classmethod\n    def create(\n        cls,\n        content: str,\n        *,\n        parent: Entry | None = None,\n        context: Entry | None = None,\n        **overrides\n    ) -&gt; UserMessage\n</code></pre>"},{"location":"api/transcript/#assistantmessage","title":"AssistantMessage","text":"<pre><code>class AssistantMessage(Entry):\n    type: Literal[\"assistant\"] = \"assistant\"\n    request_id: str\n\n    # Properties\n    message_id: str\n    model: str\n    content: list[ContentBlock]\n    stop_reason: str | None\n    usage: dict\n    text: str\n    thinking: str\n    tool_uses: list[ToolUseBlock]\n    has_tool_use: bool\n\n    # Factory\n    @classmethod\n    def create(\n        cls,\n        content: str | list[ContentBlock],\n        *,\n        parent: Entry | None = None,\n        context: Entry | None = None,\n        model: str = \"synthetic\",\n        stop_reason: str = \"end_turn\",\n        **overrides\n    ) -&gt; AssistantMessage\n</code></pre>"},{"location":"api/transcript/#systementry","title":"SystemEntry","text":"<pre><code>class SystemEntry(Entry):\n    type: Literal[\"system\"] = \"system\"\n    subtype: str\n    content: str\n    level: str\n</code></pre>"},{"location":"api/transcript/#compactboundary","title":"CompactBoundary","text":"<pre><code>class CompactBoundary(SystemEntry):\n    subtype: Literal[\"compact_boundary\"] = \"compact_boundary\"\n    logical_parent_uuid: str\n    compact_metadata: dict\n</code></pre>"},{"location":"api/transcript/#content-blocks","title":"Content Blocks","text":""},{"location":"api/transcript/#textblock","title":"TextBlock","text":"<pre><code>class TextBlock:\n    type: Literal[\"text\"] = \"text\"\n    text: str\n</code></pre>"},{"location":"api/transcript/#tooluseblock","title":"ToolUseBlock","text":"<pre><code>class ToolUseBlock:\n    type: Literal[\"tool_use\"] = \"tool_use\"\n    id: str\n    name: str\n    input: dict\n\n    # Property - finds matching result\n    result: ToolResultBlock | None\n</code></pre>"},{"location":"api/transcript/#toolresultblock","title":"ToolResultBlock","text":"<pre><code>class ToolResultBlock:\n    type: Literal[\"tool_result\"] = \"tool_result\"\n    tool_use_id: str\n    content: str\n    is_error: bool\n\n    # Property - finds matching tool use\n    tool_use: ToolUseBlock | None\n</code></pre>"},{"location":"api/transcript/#thinkingblock","title":"ThinkingBlock","text":"<pre><code>class ThinkingBlock:\n    type: Literal[\"thinking\"] = \"thinking\"\n    thinking: str\n    signature: str  # Cryptographic signature (read-only)\n</code></pre>"},{"location":"api/transcript/#turn","title":"Turn","text":"<p>Groups assistant entries by requestId.</p> <pre><code>class Turn:\n    request_id: str\n    entries: list[AssistantMessage]\n\n    # Properties\n    thinking: str\n    text: str\n    tool_uses: list[ToolUseBlock]\n    is_complete: bool\n    has_error: bool\n</code></pre>"},{"location":"api/transcript/#transcriptstats","title":"TranscriptStats","text":"<pre><code>class TranscriptStats:\n    input_tokens: int\n    output_tokens: int\n    cache_read_tokens: int\n    cache_creation_tokens: int\n    tool_calls: dict[str, int]\n    error_count: int\n    message_count: int\n    turn_count: int\n    compact_count: int\n    duration_seconds: float\n    slug: str\n</code></pre>"},{"location":"api/transcript/#factory-functions","title":"Factory Functions","text":""},{"location":"api/transcript/#inject_tool_result","title":"inject_tool_result","text":"<pre><code>from fasthooks.transcript import inject_tool_result\n\ninject_tool_result(\n    transcript: Transcript,\n    tool_name: str,\n    tool_input: dict,\n    result: str,\n    *,\n    is_error: bool = False,\n    position: int | Literal[\"start\", \"end\"] = \"end\",\n) -&gt; tuple[AssistantMessage, UserMessage]\n</code></pre> <p>Creates a matching ToolUseBlock + ToolResultBlock pair and inserts them.</p>"},{"location":"comparison/","title":"Comparisons","text":"<p>How does fasthooks compare to other approaches for building Claude Code hooks?</p>"},{"location":"comparison/#hook-libraries-frameworks","title":"Hook Libraries &amp; Frameworks","text":"Library Approach Best For cchooks Context factory (Python) Simple hooks Claude Agent SDK In-process callbacks SDK-based applications claude-mem Memory plugin (observer) Persistent AI memory Continuous-Claude-v2 Session continuity Long-running projects Raw JSON Protocol Manual stdin/stdout One-off scripts fasthooks Decorator framework (Python) CLI hook development"},{"location":"comparison/#quick-summary","title":"Quick Summary","text":"<p>fasthooks is a batteries-included framework for building Claude Code hooks with:</p> <ul> <li>Typed events with property accessors</li> <li>Response helpers (<code>allow()</code>, <code>deny()</code>, <code>block()</code>)</li> <li>Dependency injection (<code>State</code>, <code>Transcript</code>, <code>Tasks</code>)</li> <li>Background tasks for async work</li> <li>Blueprints and middleware for modularity</li> <li>Testing utilities</li> </ul> <p>cchooks is a minimal Python SDK using a context factory pattern. Explicit and lightweight, but no state management, middleware, or testing utilities. Good for simple, single-purpose hooks.</p> <p>Claude Agent SDK hooks are lightweight in-process callbacks for applications that embed Claude via the SDK. They're minimal by design - no state management, no transcript parsing, no DX conveniences.</p> <p>claude-mem is a complete memory plugin that uses hooks internally to observe tool usage. It cannot block or deny - it's an observer, not an enforcer. Great for persistent memory, not for building custom hook logic.</p> <p>Continuous-Claude-v2 is a session continuity system using hooks to preserve context across <code>/clear</code> and compaction. Features ledgers, handoffs, TypeScript preflight, and skill auto-activation. Can block on PreToolUse only.</p> <p>Raw JSON protocol is what all approaches build on. Use it directly only for simple one-off scripts.</p>"},{"location":"comparison/#detailed-comparisons","title":"Detailed Comparisons","text":"<ul> <li>cchooks - Minimal Python SDK vs batteries-included framework</li> <li>Claude Agent SDK Hooks - In-depth comparison of SDK hooks vs fasthooks</li> <li>claude-mem - Memory plugin vs hook framework</li> <li>Continuous-Claude-v2 - Session continuity system vs hook framework</li> </ul>"},{"location":"comparison/cchooks/","title":"cchooks vs fasthooks","text":"<p>cchooks is a Python SDK for building Claude Code hooks. This is the most direct comparison - both libraries solve the same problem with different approaches.</p>"},{"location":"comparison/cchooks/#same-goal-different-approaches","title":"Same Goal, Different Approaches","text":"Aspect cchooks fasthooks Pattern Context factory Decorator handlers Philosophy Minimal, explicit Batteries-included API Style <code>create_context()</code> \u2192 methods <code>@app.pre_tool()</code> \u2192 return <p>Both eliminate JSON boilerplate and provide type-safe hook development.</p>"},{"location":"comparison/cchooks/#architecture","title":"Architecture","text":""},{"location":"comparison/cchooks/#cchooks-context-factory-pattern","title":"cchooks: Context Factory Pattern","text":"<pre><code>from cchooks import create_context, PreToolUseContext\n\nc = create_context()  # Reads stdin, detects hook type\nassert isinstance(c, PreToolUseContext)\n\nif c.tool_name == \"Bash\" and \"rm -rf\" in c.tool_input.get(\"command\", \"\"):\n    c.output.deny(reason=\"Dangerous command blocked\")\nelse:\n    c.output.allow()\n</code></pre> <p>Flow: stdin \u2192 <code>create_context()</code> \u2192 type-specific context \u2192 <code>output.method()</code></p>"},{"location":"comparison/cchooks/#fasthooks-decorator-handlers","title":"fasthooks: Decorator Handlers","text":"<pre><code>from fasthooks import HookApp, deny\n\napp = HookApp()\n\n@app.pre_tool(\"Bash\")\ndef check_bash(event):\n    if \"rm -rf\" in event.command:\n        return deny(\"Dangerous command blocked\")\n\nif __name__ == \"__main__\":\n    app.run()\n</code></pre> <p>Flow: stdin \u2192 <code>app.run()</code> \u2192 route to handler \u2192 return response</p>"},{"location":"comparison/cchooks/#event-coverage","title":"Event Coverage","text":"<p>Both support all Claude Code hook events:</p> Event cchooks fasthooks PreToolUse \u2705 \u2705 PostToolUse \u2705 \u2705 Stop \u2705 \u2705 SubagentStop \u2705 \u2705 SessionStart \u2705 \u2705 SessionEnd \u2705 \u2705 UserPromptSubmit \u2705 \u2705 Notification \u2705 \u2705 PreCompact \u2705 \u2705 PermissionRequest \u274c \u2705"},{"location":"comparison/cchooks/#response-format","title":"Response Format","text":""},{"location":"comparison/cchooks/#cchooks-method-calls","title":"cchooks: Method Calls","text":"<pre><code># PreToolUse\nc.output.allow()\nc.output.deny(reason=\"Blocked\", system_message=\"Warning\")\nc.output.ask(reason=\"Please confirm\")\n\n# Stop\nc.output.prevent(reason=\"Keep working\")\nc.output.halt(reason=\"Fatal error\")\n\n# SessionStart\nc.output.add_context(\"Additional context for Claude\")\n\n# Exit codes\nc.output.exit_success()      # exit 0\nc.output.exit_non_block()    # exit 1\nc.output.exit_block()        # exit 2\n</code></pre>"},{"location":"comparison/cchooks/#fasthooks-return-values","title":"fasthooks: Return Values","text":"<pre><code>from fasthooks import allow, deny, block\n\n@app.pre_tool(\"Bash\")\ndef check(event):\n    return deny(\"Blocked\")           # Prevent execution\n    return allow(message=\"OK\")       # Continue\n    return None                      # Allow (implicit)\n\n@app.on_stop()\ndef check_stop(event):\n    return block(\"Keep working\")     # Prevent stop\n</code></pre> Action cchooks fasthooks Allow tool <code>c.output.allow()</code> <code>return allow()</code> or <code>None</code> Deny tool <code>c.output.deny(reason=...)</code> <code>return deny(\"reason\")</code> Prevent stop <code>c.output.prevent(reason=...)</code> <code>return block(\"reason\")</code> Add context <code>c.output.add_context(...)</code> <code>return allow(message=...)</code>"},{"location":"comparison/cchooks/#type-safety","title":"Type Safety","text":""},{"location":"comparison/cchooks/#cchooks-context-classes","title":"cchooks: Context Classes","text":"<pre><code>from cchooks import PreToolUseContext\n\nc = create_context()\nassert isinstance(c, PreToolUseContext)\n\nc.tool_name      # str\nc.tool_input     # dict[str, Any]\nc.session_id     # str\nc.transcript_path # str\nc.cwd            # str\n</code></pre> <p>Manual dict access for tool_input: <code>c.tool_input.get(\"command\", \"\")</code></p>"},{"location":"comparison/cchooks/#fasthooks-pydantic-models-with-properties","title":"fasthooks: Pydantic Models with Properties","text":"<pre><code>@app.pre_tool(\"Bash\")\ndef check(event):\n    event.command      # str - direct property\n    event.description  # str | None\n    event.timeout      # int | None\n    event.tool_input   # dict - raw access if needed\n</code></pre> <p>IDE autocomplete works on properties like <code>event.command</code>.</p>"},{"location":"comparison/cchooks/#handler-registration","title":"Handler Registration","text":""},{"location":"comparison/cchooks/#cchooks-single-entry-point","title":"cchooks: Single Entry Point","text":"<pre><code># hook.py - handles ONE hook type\nfrom cchooks import create_context, PreToolUseContext\n\nc = create_context()\n# Must check type manually\nif isinstance(c, PreToolUseContext):\n    # handle PreToolUse\n</code></pre> <p>Each hook type = separate file (or manual dispatch).</p>"},{"location":"comparison/cchooks/#fasthooks-multiple-handlers","title":"fasthooks: Multiple Handlers","text":"<pre><code># hooks.py - handles ALL hook types\napp = HookApp()\n\n@app.pre_tool(\"Bash\")\ndef check_bash(event): ...\n\n@app.pre_tool(\"Write\")\ndef check_write(event): ...\n\n@app.on_stop()\ndef on_stop(event): ...\n\napp.run()  # Routes automatically\n</code></pre> <p>One file can handle multiple events with automatic routing.</p>"},{"location":"comparison/cchooks/#tool-matching","title":"Tool Matching","text":""},{"location":"comparison/cchooks/#cchooks-manual-check","title":"cchooks: Manual Check","text":"<pre><code>c = create_context()\nif c.tool_name == \"Bash\":\n    # handle Bash\nelif c.tool_name in [\"Write\", \"Edit\"]:\n    # handle Write/Edit\n</code></pre>"},{"location":"comparison/cchooks/#fasthooks-decorator-routing-guards","title":"fasthooks: Decorator Routing + Guards","text":"<pre><code>@app.pre_tool(\"Bash\")           # Single tool\ndef check_bash(event): ...\n\n@app.pre_tool(\"Write\", \"Edit\")  # Multiple tools\ndef check_write(event): ...\n\n@app.pre_tool()                 # Catch-all\ndef check_any(event): ...\n\n@app.pre_tool(\"Bash\", when=lambda e: \"sudo\" in e.command)\ndef check_sudo(event): ...      # Conditional\n</code></pre>"},{"location":"comparison/cchooks/#state-management","title":"State Management","text":""},{"location":"comparison/cchooks/#cchooks-none-built-in","title":"cchooks: None Built-in","text":"<pre><code># Must manually implement persistence\nimport json\nfrom pathlib import Path\n\nSTATE_FILE = Path.home() / \".my-hook-state.json\"\n\nc = create_context()\nstate = json.loads(STATE_FILE.read_text()) if STATE_FILE.exists() else {}\nstate[\"count\"] = state.get(\"count\", 0) + 1\nSTATE_FILE.write_text(json.dumps(state))\n</code></pre>"},{"location":"comparison/cchooks/#fasthooks-dependency-injection","title":"fasthooks: Dependency Injection","text":"<pre><code>from fasthooks.depends import State, Transcript\n\n@app.pre_tool(\"Bash\")\ndef check(event, state: State, transcript: Transcript):\n    # state: auto-loaded JSON, session-scoped\n    state[\"count\"] = state.get(\"count\", 0) + 1\n    state.save()\n\n    # transcript: parsed conversation history\n    if transcript.stats.tool_calls.get(\"Bash\", 0) &gt; 100:\n        return deny(\"Rate limit exceeded\")\n</code></pre>"},{"location":"comparison/cchooks/#feature-comparison","title":"Feature Comparison","text":"Feature cchooks fasthooks Typed Events \u2705 (context classes) \u2705 (Pydantic models) Property Accessors \u274c (dict access) \u2705 (<code>event.command</code>) Response Helpers \u2705 (methods) \u2705 (functions) Multi-Handler Routing \u274c \u2705 Guards/Filters \u274c \u2705 (<code>when=</code>) Catch-All Handlers \u274c \u2705 (<code>@app.pre_tool()</code>) State Persistence \u274c \u2705 (<code>State</code>) Transcript Parsing \u274c \u2705 (<code>Transcript</code>) Background Tasks \u274c \u2705 (<code>Tasks</code>) Blueprints \u274c \u2705 Middleware \u274c \u2705 Testing Utils \u274c \u2705 (<code>MockEvent</code>, <code>TestClient</code>) Tool Input Modification \u2705 (<code>updated_input</code>) \u274c Safe Error Handling \u2705 (<code>safe_create_context</code>) \u2705"},{"location":"comparison/cchooks/#unique-to-cchooks","title":"Unique to cchooks","text":""},{"location":"comparison/cchooks/#tool-input-modification","title":"Tool Input Modification","text":"<p>cchooks can modify tool inputs before execution:</p> <pre><code>c = create_context()\nif c.tool_name == \"Write\":\n    # Redirect writes to safe location\n    c.output.allow(\n        updated_input={\"file_path\": \"/safe/location/\" + c.tool_input[\"file_path\"]}\n    )\n</code></pre> <p>fasthooks currently doesn't support <code>updated_input</code>.</p>"},{"location":"comparison/cchooks/#exit-code-control","title":"Exit Code Control","text":"<p>cchooks provides explicit exit code methods:</p> <pre><code>c.output.exit_success()      # exit 0 - success, stdout in transcript\nc.output.exit_non_block()    # exit 1 - error shown to user\nc.output.exit_block()        # exit 2 - blocking error\n</code></pre>"},{"location":"comparison/cchooks/#unique-to-fasthooks","title":"Unique to fasthooks","text":""},{"location":"comparison/cchooks/#dependency-injection","title":"Dependency Injection","text":"<pre><code>@app.pre_tool(\"Bash\")\ndef handler(event, state: State, transcript: Transcript, tasks: Tasks):\n    # All injected automatically based on type hints\n</code></pre>"},{"location":"comparison/cchooks/#blueprints","title":"Blueprints","text":"<pre><code>security = Blueprint()\n\n@security.pre_tool(\"Bash\")\ndef no_sudo(event):\n    if \"sudo\" in event.command:\n        return deny(\"No sudo\")\n\napp.include(security)\n</code></pre>"},{"location":"comparison/cchooks/#middleware","title":"Middleware","text":"<pre><code>@app.middleware\ndef timing(event, call_next):\n    start = time.time()\n    response = call_next(event)\n    print(f\"Hook took {time.time() - start:.3f}s\")\n    return response\n</code></pre>"},{"location":"comparison/cchooks/#testing-utilities","title":"Testing Utilities","text":"<pre><code>from fasthooks.testing import MockEvent, TestClient\n\ndef test_blocks_rm():\n    client = TestClient(app)\n    response = client.send(MockEvent.bash(command=\"rm -rf /\"))\n    assert response.decision == \"deny\"\n</code></pre>"},{"location":"comparison/cchooks/#background-tasks","title":"Background Tasks","text":"<pre><code>from fasthooks.tasks import task, Tasks\n\n@task\ndef analyze(code: str) -&gt; str:\n    return expensive_analysis(code)\n\n@app.pre_tool(\"Write\")\ndef on_write(event, tasks: Tasks):\n    tasks.add(analyze, event.content)\n</code></pre>"},{"location":"comparison/cchooks/#code-comparison","title":"Code Comparison","text":""},{"location":"comparison/cchooks/#blocking-dangerous-commands","title":"Blocking Dangerous Commands","text":"<p>cchooks: <pre><code>#!/usr/bin/env python3\nfrom cchooks import create_context, PreToolUseContext\n\nc = create_context()\nassert isinstance(c, PreToolUseContext)\n\nif c.tool_name == \"Bash\":\n    cmd = c.tool_input.get(\"command\", \"\")\n    if \"rm -rf\" in cmd:\n        c.output.deny(reason=\"Dangerous command blocked\")\n    else:\n        c.output.allow()\nelse:\n    c.output.allow()\n</code></pre></p> <p>fasthooks: <pre><code>#!/usr/bin/env python3\nfrom fasthooks import HookApp, deny\n\napp = HookApp()\n\n@app.pre_tool(\"Bash\")\ndef check_bash(event):\n    if \"rm -rf\" in event.command:\n        return deny(\"Dangerous command blocked\")\n\nif __name__ == \"__main__\":\n    app.run()\n</code></pre></p>"},{"location":"comparison/cchooks/#rate-limiting-with-state","title":"Rate Limiting with State","text":"<p>cchooks: <pre><code>#!/usr/bin/env python3\nimport json\nfrom pathlib import Path\nfrom cchooks import create_context, PreToolUseContext\n\nSTATE_FILE = Path.home() / \".hook-state.json\"\n\nc = create_context()\nassert isinstance(c, PreToolUseContext)\n\n# Manual state management\nstate = json.loads(STATE_FILE.read_text()) if STATE_FILE.exists() else {}\ncount = state.get(\"bash_count\", 0) + 1\nstate[\"bash_count\"] = count\nSTATE_FILE.write_text(json.dumps(state))\n\nif count &gt; 100:\n    c.output.deny(reason=f\"Rate limit: {count}/100 commands\")\nelse:\n    c.output.allow()\n</code></pre></p> <p>fasthooks: <pre><code>#!/usr/bin/env python3\nfrom fasthooks import HookApp, deny\nfrom fasthooks.depends import State\n\napp = HookApp(state_dir=\"/tmp/hook-state\")\n\n@app.pre_tool(\"Bash\")\ndef rate_limit(event, state: State):\n    count = state.get(\"bash_count\", 0) + 1\n    state[\"bash_count\"] = count\n    state.save()\n\n    if count &gt; 100:\n        return deny(f\"Rate limit: {count}/100 commands\")\n\nif __name__ == \"__main__\":\n    app.run()\n</code></pre></p>"},{"location":"comparison/cchooks/#when-to-use-each","title":"When to Use Each","text":""},{"location":"comparison/cchooks/#use-cchooks-when","title":"Use cchooks When:","text":"<ul> <li>You want a minimal, lightweight SDK</li> <li>You prefer explicit control over magic</li> <li>You need tool input modification (<code>updated_input</code>)</li> <li>You're building simple, single-purpose hooks</li> <li>You don't need state management or testing utilities</li> </ul>"},{"location":"comparison/cchooks/#use-fasthooks-when","title":"Use fasthooks When:","text":"<ul> <li>You want batteries-included with DI, state, transcripts</li> <li>You prefer decorator-based handler registration</li> <li>You need multiple handlers in one file</li> <li>You want guards and filters for conditional logic</li> <li>You need testing utilities for TDD</li> <li>You're building complex, multi-event hook systems</li> <li>You want blueprints for modular organization</li> </ul>"},{"location":"comparison/cchooks/#summary","title":"Summary","text":"Aspect cchooks fasthooks Philosophy Minimal, explicit Batteries-included API Style Context factory Decorators Learning Curve Lower Slightly higher Boilerplate More Less Features Core only Rich ecosystem Best For Simple hooks Complex systems"},{"location":"comparison/claude-agent-sdk/","title":"Claude Agent SDK Hooks vs fasthooks","text":"<p>The Claude Agent SDK provides in-process hook callbacks for applications that embed Claude. This page compares SDK hooks with fasthooks.</p>"},{"location":"comparison/claude-agent-sdk/#architecture","title":"Architecture","text":"Aspect Claude Agent SDK fasthooks Execution Model In-process async callback Subprocess per hook call Protocol Bidirectional stream (SDK \u2194 CLI) Stdin/stdout JSON Context Runs inside SDK application Spawned by Claude Code CLI Async Required (<code>async def</code>) Optional <p>SDK hooks run inside your Python application alongside the SDK client. The CLI sends hook events over a bidirectional stream, and your callback responds immediately.</p> <p>fasthooks runs as a separate process spawned by Claude Code. Each hook invocation starts a fresh process, reads JSON from stdin, and writes the response to stdout.</p>"},{"location":"comparison/claude-agent-sdk/#event-coverage","title":"Event Coverage","text":"Event SDK fasthooks PreToolUse \u2705 \u2705 PostToolUse \u2705 \u2705 UserPromptSubmit \u2705 \u2705 Stop \u2705 \u2705 SubagentStop \u2705 \u2705 PreCompact \u2705 \u2705 SessionStart \u274c \u2705 SessionEnd \u274c \u2705 Notification \u274c \u2705 PermissionRequest \u274c* \u2705 <p>*SDK uses <code>can_use_tool</code> callback instead of PermissionRequest hooks.</p> <p>SDK Limitations</p> <p>The SDK documentation states: \"Due to setup limitations, the Python SDK does not support SessionStart, SessionEnd, and Notification hooks.\"</p>"},{"location":"comparison/claude-agent-sdk/#developer-experience","title":"Developer Experience","text":""},{"location":"comparison/claude-agent-sdk/#sdk-hooks-manual-verbose","title":"SDK Hooks - Manual &amp; Verbose","text":"<pre><code>from claude_agent_sdk import ClaudeAgentOptions, ClaudeSDKClient, HookMatcher\n\nasync def check_bash(input_data, tool_use_id, context):\n    # Manual tool name check (no routing)\n    if input_data[\"tool_name\"] != \"Bash\":\n        return {}\n\n    # Manual dict access (no typed properties)\n    command = input_data[\"tool_input\"].get(\"command\", \"\")\n\n    if \"rm -rf\" in command:\n        # Manual response dict construction\n        return {\n            \"hookSpecificOutput\": {\n                \"hookEventName\": \"PreToolUse\",\n                \"permissionDecision\": \"deny\",\n                \"permissionDecisionReason\": \"Dangerous command blocked\",\n            }\n        }\n    return {}\n\n# Manual registration\noptions = ClaudeAgentOptions(\n    hooks={\n        \"PreToolUse\": [\n            HookMatcher(matcher=\"Bash\", hooks=[check_bash]),\n        ],\n    }\n)\n\nasync with ClaudeSDKClient(options=options) as client:\n    await client.query(\"Run rm -rf /\")\n    async for msg in client.receive_response():\n        print(msg)\n</code></pre>"},{"location":"comparison/claude-agent-sdk/#fasthooks-concise-typed","title":"fasthooks - Concise &amp; Typed","text":"<pre><code>from fasthooks import HookApp, deny\n\napp = HookApp()\n\n@app.pre_tool(\"Bash\")  # Decorator routing\ndef check_bash(event):\n    # Typed property access\n    if \"rm -rf\" in event.command:\n        return deny(\"Dangerous command blocked\")  # Helper function\n\nif __name__ == \"__main__\":\n    app.run()\n</code></pre> <p>Key DX differences:</p> Aspect SDK fasthooks Routing Manual <code>if tool_name</code> check <code>@app.pre_tool(\"Bash\")</code> decorator Event access <code>input_data[\"tool_input\"][\"command\"]</code> <code>event.command</code> Response Raw dict with nested structure <code>deny(\"reason\")</code> Registration Dict in options Decorator"},{"location":"comparison/claude-agent-sdk/#feature-matrix","title":"Feature Matrix","text":"Feature SDK fasthooks Typed events TypedDict Pydantic + properties Response helpers \u274c <code>allow()</code>, <code>deny()</code>, <code>block()</code> Tool matchers String only Decorators + <code>when=</code> guards Multiple tools <code>\"Write\\|Edit\"</code> regex <code>@app.pre_tool(\"Write\", \"Edit\")</code> Catch-all <code>matcher=None</code> <code>@app.pre_tool()</code> or <code>\"*\"</code> State persistence \u274c <code>State</code> dependency Transcript parsing \u274c <code>Transcript</code> dependency Background tasks \u274c <code>Tasks</code> dependency Blueprints \u274c <code>Blueprint</code> class Middleware \u274c <code>@app.middleware</code> Testing utils \u274c <code>MockEvent</code>, <code>TestClient</code>"},{"location":"comparison/claude-agent-sdk/#statefulness","title":"Statefulness","text":""},{"location":"comparison/claude-agent-sdk/#sdk-hooks-stateless","title":"SDK Hooks - Stateless","text":"<p>SDK hooks have no built-in state management. Each callback is stateless:</p> <pre><code># SDK: No state between calls\nasync def my_hook(input_data, tool_use_id, context):\n    # Must manually read transcript_path if you need history\n    transcript_path = input_data.get(\"transcript_path\")\n    # Must implement your own persistence\n    return {}\n</code></pre>"},{"location":"comparison/claude-agent-sdk/#fasthooks-built-in-state-transcript","title":"fasthooks - Built-in State &amp; Transcript","text":"<pre><code>from fasthooks.depends import State, Transcript\n\n@app.pre_tool(\"Bash\")\ndef rate_limit(event, state: State, transcript: Transcript):\n    # state: persisted dict (JSON file per session)\n    count = state.get(\"bash_count\", 0) + 1\n    state[\"bash_count\"] = count\n    state.save()\n\n    # transcript: parsed history with aggregated stats\n    stats = transcript.stats\n    if stats.tool_calls.get(\"Bash\", 0) &gt; 100:\n        return deny(f\"Rate limit: {stats.tool_calls['Bash']} bash commands\")\n\n    # Access token usage, duration, file counts, etc.\n    print(f\"Session tokens: {stats.total_tokens}\")\n    print(f\"Duration: {stats.duration_seconds}s\")\n</code></pre>"},{"location":"comparison/claude-agent-sdk/#background-tasks","title":"Background Tasks","text":"<p>SDK hooks have no background task support. fasthooks provides async work that feeds back in subsequent hooks:</p> <pre><code>from fasthooks.tasks import task, Tasks\n\n@task\ndef analyze_code(code: str) -&gt; str:\n    # Runs in thread pool, non-blocking\n    return expensive_analysis(code)\n\n@app.pre_tool(\"Write\")\ndef on_write(event, tasks: Tasks):\n    tasks.add(analyze_code, event.content)  # Fire and forget\n    return allow()\n\n@app.on_prompt()\ndef check_analysis(event, tasks: Tasks):\n    if result := tasks.pop(analyze_code):  # Check if done\n        return allow(message=f\"Analysis: {result}\")\n    return allow()\n</code></pre>"},{"location":"comparison/claude-agent-sdk/#when-to-use-each","title":"When to Use Each","text":""},{"location":"comparison/claude-agent-sdk/#use-sdk-hooks-when","title":"Use SDK Hooks When:","text":"<ul> <li>Building an application that embeds Claude via the SDK</li> <li>You need in-process callbacks (no subprocess overhead)</li> <li>You're already using <code>ClaudeSDKClient</code> for custom tools</li> <li>You want hooks and custom MCP tools in the same process</li> </ul> <pre><code># SDK: Hooks + custom tools in one application\noptions = ClaudeAgentOptions(\n    mcp_servers={\"tools\": my_sdk_mcp_server},\n    hooks={\"PreToolUse\": [HookMatcher(matcher=\"Bash\", hooks=[my_hook])]},\n)\n\nasync with ClaudeSDKClient(options=options) as client:\n    # Interactive conversation with hooks\n    await client.query(\"...\")\n</code></pre>"},{"location":"comparison/claude-agent-sdk/#use-fasthooks-when","title":"Use fasthooks When:","text":"<ul> <li>You're a CLI user customizing Claude Code behavior</li> <li>You need persistent state across hook invocations</li> <li>You need transcript analysis (token counts, tool usage stats)</li> <li>You need background async work (API calls, Claude sub-agents)</li> <li>You need SessionStart, SessionEnd, or Notification events</li> <li>You're building reusable hook libraries</li> <li>You want FastAPI-like DX with dependency injection</li> </ul> <pre><code># fasthooks: Standalone hook with full features\nfrom fasthooks import HookApp, allow, deny\nfrom fasthooks.depends import State, Transcript\nfrom fasthooks.tasks import Tasks\n\napp = HookApp(state_dir=\"/tmp/hooks-state\")\n\n@app.pre_tool(\"Bash\")\ndef check(event, state: State, transcript: Transcript, tasks: Tasks):\n    # Full access to state, history, and background tasks\n    ...\n\nif __name__ == \"__main__\":\n    app.run()\n</code></pre>"},{"location":"comparison/claude-agent-sdk/#migration-path","title":"Migration Path","text":"<p>If you're using SDK hooks and want fasthooks features:</p> <p>Option 1: Use fasthooks for CLI hooks, SDK for embedded apps</p> <p>They serve different use cases and can coexist.</p> <p>Option 2: Call fasthooks from SDK hooks</p> <p>For complex logic, you could spawn fasthooks as a subprocess from SDK hooks, though this adds overhead.</p> <p>Option 3: Use fasthooks' Claude sub-agent integration</p> <p>fasthooks can spawn Claude sub-agents via the SDK for AI-powered background tasks:</p> <pre><code>from fasthooks.contrib.claude import agent_task, ClaudeAgent\nfrom fasthooks.tasks import Tasks\n\n@agent_task(model=\"haiku\", system_prompt=\"Review code for bugs.\")\nasync def review_code(agent: ClaudeAgent, code: str) -&gt; str:\n    return await agent.query(f\"Review:\\n{code}\")\n\n@app.pre_tool(\"Write\")\ndef on_write(event, tasks: Tasks):\n    tasks.add(review_code, event.content)\n    return allow()\n</code></pre>"},{"location":"comparison/claude-agent-sdk/#summary","title":"Summary","text":"Aspect SDK Hooks fasthooks Philosophy Minimal, in-process Batteries-included framework Best for SDK applications CLI hook development DX Manual, verbose FastAPI-like, concise State DIY Built-in Events 6 types 9+ types Ecosystem Part of SDK Standalone library"},{"location":"comparison/claude-mem/","title":"claude-mem vs fasthooks","text":"<p>claude-mem is a Claude Code plugin that provides persistent AI memory across sessions. This page compares its hook implementation with fasthooks.</p>"},{"location":"comparison/claude-mem/#different-goals","title":"Different Goals","text":"Aspect claude-mem fasthooks Primary Purpose Persistent memory system Hook development framework Philosophy Observer (capture &amp; store) Enforcer (validate &amp; control) Can Block Claude? No - always allows Yes - <code>deny()</code>, <code>block()</code> Target User End users wanting memory Developers building hooks <p>claude-mem is a complete application that happens to use hooks internally. It captures tool usage, generates semantic observations via Claude, and injects context into new sessions.</p> <p>fasthooks is a framework for building custom hooks with any logic you need - security policies, rate limiting, code review, etc.</p>"},{"location":"comparison/claude-mem/#architecture-comparison","title":"Architecture Comparison","text":""},{"location":"comparison/claude-mem/#claude-mem-http-client-worker-service","title":"claude-mem: HTTP Client + Worker Service","text":"<pre><code>\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502              Claude Code Session                \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n         \u2502 (spawns hooks)\n         \u25bc\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502  Hook Scripts (Node.js)                         \u2502\n\u2502  - context-hook.js                              \u2502\n\u2502  - save-hook.js                                 \u2502\n\u2502  - summary-hook.js                              \u2502\n\u2502  - new-hook.js                                  \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n         \u2502 (HTTP requests)\n         \u25bc\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502  Worker Service (localhost:37777)               \u2502\n\u2502  - Express HTTP server                          \u2502\n\u2502  - SQLite + Chroma storage                      \u2502\n\u2502  - Claude Agent SDK for observations            \u2502\n\u2502  - Web UI viewer                                \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> <p>Hooks are thin HTTP clients that delegate to a persistent worker service.</p>"},{"location":"comparison/claude-mem/#fasthooks-self-contained-subprocess","title":"fasthooks: Self-Contained Subprocess","text":"<pre><code>\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502              Claude Code Session                \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n         \u2502 (spawns hook)\n         \u25bc\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502  fasthooks Process                              \u2502\n\u2502  - Read JSON from stdin                         \u2502\n\u2502  - Route to handler via decorators              \u2502\n\u2502  - Execute handler with DI dependencies         \u2502\n\u2502  - Write JSON response to stdout                \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> <p>Each hook invocation is self-contained with built-in state persistence.</p>"},{"location":"comparison/claude-mem/#hook-response-model","title":"Hook Response Model","text":""},{"location":"comparison/claude-mem/#claude-mem-observer-only","title":"claude-mem: Observer Only","text":"<pre><code>// claude-mem always returns \"continue\"\nexport const STANDARD_HOOK_RESPONSE = JSON.stringify({\n  continue: true,\n  suppressOutput: true\n});\n\n// Only SessionStart can inject context\nconsole.log(JSON.stringify({\n  hookSpecificOutput: {\n    hookEventName: \"SessionStart\",\n    additionalContext: \"Previous session context...\",\n  },\n}));\n</code></pre> <p>Cannot prevent tool execution - hooks observe and record, never block.</p>"},{"location":"comparison/claude-mem/#fasthooks-full-control","title":"fasthooks: Full Control","text":"<pre><code>from fasthooks import allow, deny, block\n\n@app.pre_tool(\"Bash\")\ndef check_bash(event):\n    if \"rm -rf\" in event.command:\n        return deny(\"Dangerous command blocked\")  # Prevents execution\n    return allow()\n\n@app.on_stop()\ndef prevent_stop(event):\n    if not all_tests_passed():\n        return block(\"Tests still failing\")  # Keeps Claude working\n    return allow()\n</code></pre> <p>Full enforcement capability - allow, deny, block, modify inputs.</p>"},{"location":"comparison/claude-mem/#event-coverage","title":"Event Coverage","text":"Event claude-mem fasthooks PreToolUse \u274c \u2705 PostToolUse \u2705 \u2705 Stop \u2705 \u2705 SubagentStop \u274c \u2705 SessionStart \u2705 \u2705 SessionEnd \u274c \u2705 UserPromptSubmit \u2705 \u2705 Notification \u274c \u2705 PreCompact \u274c \u2705 PermissionRequest \u274c \u2705 <p>claude-mem only implements events needed for memory capture. fasthooks supports all Claude Code hook events.</p>"},{"location":"comparison/claude-mem/#type-safety","title":"Type Safety","text":""},{"location":"comparison/claude-mem/#claude-mem-interfaces-no-validation","title":"claude-mem: Interfaces (No Validation)","text":"<pre><code>// Interface defined but not validated at runtime\nexport interface PostToolUseInput {\n  session_id: string;\n  cwd: string;\n  tool_name: string;\n  tool_input: any;      // No type safety\n  tool_response: any;   // No type safety\n}\n\n// Manual JSON parsing, no validation\nconst parsed = input ? JSON.parse(input) : undefined;\nawait saveHook(parsed);  // May fail at runtime\n</code></pre>"},{"location":"comparison/claude-mem/#fasthooks-pydantic-models-with-properties","title":"fasthooks: Pydantic Models with Properties","text":"<pre><code># Validated Pydantic models with typed properties\n@app.pre_tool(\"Bash\")\ndef handler(event):\n    event.command      # str - typed, autocomplete works\n    event.description  # str | None\n    event.timeout      # int | None\n    event.tool_input   # dict - full access if needed\n</code></pre>"},{"location":"comparison/claude-mem/#state-management","title":"State Management","text":""},{"location":"comparison/claude-mem/#claude-mem-external-database","title":"claude-mem: External Database","text":"<pre><code>// Hooks call worker API, worker manages SQLite + Chroma\nconst response = await fetch(`http://127.0.0.1:${port}/api/sessions/observations`, {\n  method: 'POST',\n  body: JSON.stringify({ contentSessionId, tool_name, tool_input, tool_response })\n});\n\n// Worker handles:\n// - SQLite for structured data (sessions, observations, summaries)\n// - Chroma for vector search (semantic embeddings)\n// - Settings JSON file\n</code></pre> <p>Pros: Rich storage (SQL + vector), shared across hooks Cons: Requires running worker service, HTTP overhead</p>"},{"location":"comparison/claude-mem/#fasthooks-dependency-injection","title":"fasthooks: Dependency Injection","text":"<pre><code>from fasthooks.depends import State, Transcript\n\n@app.pre_tool(\"Bash\")\ndef handler(event, state: State, transcript: Transcript):\n    # state: JSON file per session, auto-loaded\n    count = state.get(\"bash_count\", 0) + 1\n    state[\"bash_count\"] = count\n    state.save()\n\n    # transcript: Parsed conversation history with stats\n    if transcript.stats.tool_calls.get(\"Bash\", 0) &gt; 100:\n        return deny(\"Rate limit exceeded\")\n</code></pre> <p>Pros: Zero setup, injected automatically, no external services Cons: Simpler storage (JSON), no vector search built-in</p>"},{"location":"comparison/claude-mem/#hook-registration","title":"Hook Registration","text":""},{"location":"comparison/claude-mem/#claude-mem-monolithic-json","title":"claude-mem: Monolithic JSON","text":"<pre><code>{\n  \"hooks\": {\n    \"SessionStart\": [\n      {\n        \"matcher\": \"startup|clear|compact\",\n        \"hooks\": [\n          { \"type\": \"command\", \"command\": \"node smart-install.js\", \"timeout\": 300 },\n          { \"type\": \"command\", \"command\": \"bun worker-service.cjs start\", \"timeout\": 15 },\n          { \"type\": \"command\", \"command\": \"node context-hook.js\", \"timeout\": 15 }\n        ]\n      }\n    ],\n    \"PostToolUse\": [\n      {\n        \"hooks\": [\n          { \"type\": \"command\", \"command\": \"node save-hook.js\", \"timeout\": 300 }\n        ]\n      }\n    ]\n  }\n}\n</code></pre> <p>Single JSON file, multiple commands per event, sequential execution.</p>"},{"location":"comparison/claude-mem/#fasthooks-decorators-blueprints","title":"fasthooks: Decorators + Blueprints","text":"<pre><code>from fasthooks import HookApp, Blueprint\n\n# Main app\napp = HookApp()\n\n@app.pre_tool(\"Bash\")\ndef check_bash(event):\n    ...\n\n# Modular blueprints\nsecurity = Blueprint()\n\n@security.pre_tool(\"Write\")\ndef check_write(event):\n    ...\n\napp.include(security)\n</code></pre> <p>Decorator-based registration, composable blueprints, guards for filtering.</p>"},{"location":"comparison/claude-mem/#error-handling","title":"Error Handling","text":""},{"location":"comparison/claude-mem/#claude-mem-throw-log","title":"claude-mem: Throw &amp; Log","text":"<pre><code>async function saveHook(input?: PostToolUseInput): Promise&lt;void&gt; {\n  if (!input) {\n    throw new Error('saveHook requires input');  // Process exits with code 1\n  }\n\n  const response = await fetch(...);\n  if (!response.ok) {\n    throw new Error(`Observation storage failed: ${response.status}`);\n  }\n\n  console.log(STANDARD_HOOK_RESPONSE);\n}\n</code></pre> <p>Errors propagate, logged to file, Claude continues (graceful degradation).</p>"},{"location":"comparison/claude-mem/#fasthooks-structured-responses","title":"fasthooks: Structured Responses","text":"<pre><code>@app.pre_tool(\"Bash\")\ndef handler(event):\n    try:\n        validate_command(event.command)\n    except SecurityError as e:\n        return deny(str(e))  # Structured denial\n    return allow()\n</code></pre> <p>Errors become structured responses that Claude understands.</p>"},{"location":"comparison/claude-mem/#testing","title":"Testing","text":""},{"location":"comparison/claude-mem/#claude-mem-integration-tests","title":"claude-mem: Integration Tests","text":"<pre><code>// Spawn real hook processes, check JSON output\nfunction runHookScript(scriptName: string, input: object): string {\n  const result = execSync(`bash \"${scriptPath}\"`, {\n    input: JSON.stringify(input),\n  });\n  return result.toString('utf-8');\n}\n\nit('should output valid JSON', () =&gt; {\n  const output = runHookScript('session-init.sh', { ... });\n  expect(() =&gt; JSON.parse(output)).not.toThrow();\n});\n</code></pre> <p>No mocking utilities - tests spawn real processes.</p>"},{"location":"comparison/claude-mem/#fasthooks-mockevent-testclient","title":"fasthooks: MockEvent + TestClient","text":"<pre><code>from fasthooks.testing import MockEvent, TestClient\n\ndef test_blocks_dangerous_commands():\n    app = HookApp()\n\n    @app.pre_tool(\"Bash\")\n    def handler(event):\n        if \"rm -rf\" in event.command:\n            return deny(\"Blocked\")\n\n    client = TestClient(app)\n\n    # Mock events without spawning processes\n    response = client.send(MockEvent.bash(command=\"rm -rf /\"))\n    assert response.decision == \"deny\"\n\n    response = client.send(MockEvent.bash(command=\"ls\"))\n    assert response is None  # Allowed\n</code></pre> <p>First-class testing utilities with mock events.</p>"},{"location":"comparison/claude-mem/#feature-matrix","title":"Feature Matrix","text":"Feature claude-mem fasthooks Hook Framework \u274c (app, not framework) \u2705 Deny/Block \u274c \u2705 Typed Events Partial (interfaces) \u2705 (Pydantic) Property Accessors \u274c \u2705 (<code>event.command</code>) State Persistence \u2705 (SQLite) \u2705 (JSON) Transcript Parsing \u2705 (via SDK) \u2705 (built-in) Vector Search \u2705 (Chroma) \u274c Background Tasks \u2705 (SDK agent) \u2705 (<code>Tasks</code>) Blueprints \u274c \u2705 Middleware \u274c \u2705 Guards \u274c \u2705 (<code>when=</code>) Testing Utils \u274c \u2705 Web UI \u2705 \u274c Memory/RAG \u2705 (core feature) \u274c"},{"location":"comparison/claude-mem/#when-to-use-each","title":"When to Use Each","text":""},{"location":"comparison/claude-mem/#use-claude-mem-when","title":"Use claude-mem When:","text":"<ul> <li>You want persistent memory across Claude Code sessions</li> <li>You need semantic search over past conversations</li> <li>You want a ready-to-use solution (not building custom hooks)</li> <li>You're okay with running a background service</li> <li>You don't need to block or modify Claude's actions</li> </ul>"},{"location":"comparison/claude-mem/#use-fasthooks-when","title":"Use fasthooks When:","text":"<ul> <li>You're building custom hooks with specific logic</li> <li>You need to enforce policies (deny dangerous commands, rate limit)</li> <li>You want typed events with IDE autocomplete</li> <li>You need modular composition (blueprints, middleware)</li> <li>You want easy testing with mock events</li> <li>You prefer self-contained hooks (no external services)</li> </ul>"},{"location":"comparison/claude-mem/#using-both-together","title":"Using Both Together","text":"<p>claude-mem and fasthooks serve different purposes and can coexist:</p> <pre><code>{\n  \"hooks\": {\n    \"PreToolUse\": [\n      { \"command\": \"python /path/to/fasthooks/security.py\" }\n    ],\n    \"PostToolUse\": [\n      { \"command\": \"python /path/to/fasthooks/audit.py\" },\n      { \"command\": \"node /path/to/claude-mem/save-hook.js\" }\n    ],\n    \"SessionStart\": [\n      { \"command\": \"node /path/to/claude-mem/context-hook.js\" }\n    ]\n  }\n}\n</code></pre> <ul> <li>fasthooks for PreToolUse enforcement (block dangerous commands)</li> <li>claude-mem for PostToolUse observation (capture what happened)</li> <li>Both can run on the same events (sequential execution)</li> </ul>"},{"location":"comparison/claude-mem/#summary","title":"Summary","text":"Aspect claude-mem fasthooks What It Is Memory plugin Hook framework Philosophy Observe &amp; remember Validate &amp; control Best For Persistent context Custom hook logic Complexity Full application Library Dependencies Worker service, Bun, SQLite, Chroma None (pure Python)"},{"location":"comparison/continuous-claude/","title":"Continuous-Claude-v2 vs fasthooks","text":"<p>Continuous-Claude-v2 is a session continuity system that preserves context across Claude Code sessions. This page compares its hook implementation with fasthooks.</p>"},{"location":"comparison/continuous-claude/#different-goals","title":"Different Goals","text":"Aspect Continuous-Claude-v2 fasthooks Primary Purpose Session continuity Hook development framework Philosophy Preserve state across clears Build custom hook logic Core Feature Ledgers + handoffs Typed events + DI Target User Power users wanting continuity Developers building hooks <p>Continuous-Claude-v2 solves context degradation - when Claude compacts, you lose signal. Instead of fighting compaction, it embraces <code>/clear</code> with preserved state via ledgers and handoffs.</p> <p>fasthooks is a framework for building any hook logic - security policies, rate limiting, code review, integrations.</p>"},{"location":"comparison/continuous-claude/#architecture-comparison","title":"Architecture Comparison","text":""},{"location":"comparison/continuous-claude/#continuous-claude-v2-pre-bundled-typescript","title":"Continuous-Claude-v2: Pre-bundled TypeScript","text":"<pre><code>.claude/hooks/\n\u251c\u2500\u2500 src/                    # TypeScript source\n\u2502   \u251c\u2500\u2500 session-start-continuity.ts\n\u2502   \u251c\u2500\u2500 typescript-preflight.ts\n\u2502   \u2514\u2500\u2500 ...\n\u251c\u2500\u2500 dist/                   # Pre-compiled JS (committed)\n\u2502   \u251c\u2500\u2500 session-start-continuity.mjs\n\u2502   \u2514\u2500\u2500 ...\n\u251c\u2500\u2500 *.sh                    # Shell wrappers\n\u2502   \u251c\u2500\u2500 session-start.sh    \u2192 node dist/session-start-continuity.mjs\n\u2502   \u2514\u2500\u2500 ...\n\u2514\u2500\u2500 build.sh                # Rebuild after source changes\n</code></pre> <p>Deployment: Copy <code>.claude/hooks/</code>, make scripts executable. No npm install needed.</p>"},{"location":"comparison/continuous-claude/#fasthooks-pure-python","title":"fasthooks: Pure Python","text":"<pre><code># hooks.py\nfrom fasthooks import HookApp, deny\n\napp = HookApp()\n\n@app.pre_tool(\"Bash\")\ndef check_bash(event):\n    if \"rm -rf\" in event.command:\n        return deny(\"Blocked\")\n\nif __name__ == \"__main__\":\n    app.run()\n</code></pre> <p>Deployment: <code>pip install fasthooks</code>, point Claude Code to <code>python hooks.py</code>.</p>"},{"location":"comparison/continuous-claude/#hook-events-supported","title":"Hook Events Supported","text":"Event Continuous-Claude fasthooks SessionStart \u2705 \u2705 PreToolUse \u2705 \u2705 PostToolUse \u2705 \u2705 PreCompact \u2705 \u2705 UserPromptSubmit \u2705 \u2705 SubagentStop \u2705 \u2705 SessionEnd \u2705 \u2705 Stop \u274c \u2705 Notification \u274c \u2705 PermissionRequest \u274c \u2705 <p>Both cover core events. fasthooks has broader coverage.</p>"},{"location":"comparison/continuous-claude/#response-format","title":"Response Format","text":""},{"location":"comparison/continuous-claude/#continuous-claude-v2-manual-json","title":"Continuous-Claude-v2: Manual JSON","text":"<pre><code>// Block decision (PreToolUse only)\nconsole.log(JSON.stringify({\n  decision: 'block',\n  reason: 'TypeScript errors found:\\n  Line 15: Property does not exist'\n}));\n\n// Context injection\nconsole.log(JSON.stringify({\n  result: 'continue',\n  hookSpecificOutput: {\n    hookEventName: 'SessionStart',\n    additionalContext: ledgerContent + '\\n\\n' + handoffContent\n  }\n}));\n\n// Simple continue\nconsole.log(JSON.stringify({ continue: true }));\n</code></pre>"},{"location":"comparison/continuous-claude/#fasthooks-helper-functions","title":"fasthooks: Helper Functions","text":"<pre><code>from fasthooks import allow, deny, block\n\n@app.pre_tool(\"Bash\")\ndef check(event):\n    if dangerous(event.command):\n        return deny(\"Blocked\")        # Block with reason\n    return allow(message=\"Approved\")  # Continue with message\n\n@app.on_stop()\ndef prevent_stop(event):\n    return block(\"Keep working\")      # Prevent stopping\n</code></pre> Aspect Continuous-Claude fasthooks Block tool <code>decision: 'block'</code> <code>deny(\"reason\")</code> Allow <code>continue: true</code> <code>allow()</code> or <code>None</code> Inject context <code>hookSpecificOutput.additionalContext</code> <code>allow(message=...)</code> Block stop Not supported <code>block(\"reason\")</code>"},{"location":"comparison/continuous-claude/#blocking-capability","title":"Blocking Capability","text":""},{"location":"comparison/continuous-claude/#continuous-claude-v2-pretooluse-only","title":"Continuous-Claude-v2: PreToolUse Only","text":"<pre><code>// typescript-preflight.ts - blocks on type errors\nif (checkResult.has_errors) {\n  console.log(JSON.stringify({\n    decision: 'block',\n    reason: `\u26a0\ufe0f TypeScript Pre-flight: ${checkResult.summary}`\n  }));\n  return;\n}\n</code></pre> <p>Only PreToolUse can block. Other events just continue or inject context.</p>"},{"location":"comparison/continuous-claude/#fasthooks-any-event","title":"fasthooks: Any Event","text":"<pre><code>@app.pre_tool(\"Write\")\ndef check_write(event):\n    if \".env\" in event.file_path:\n        return deny(\"Cannot modify .env\")\n\n@app.on_stop()\ndef require_tests(event, transcript: Transcript):\n    if transcript.stats.tool_calls.get(\"Bash\", 0) == 0:\n        return block(\"Run tests before stopping\")\n\n@app.on_prompt()\ndef rate_limit(event, state: State):\n    if state.get(\"prompts\", 0) &gt; 100:\n        return deny(\"Rate limit exceeded\")\n</code></pre> <p>Any handler can deny/block, not just PreToolUse.</p>"},{"location":"comparison/continuous-claude/#state-management","title":"State Management","text":""},{"location":"comparison/continuous-claude/#continuous-claude-v2-three-layer-system","title":"Continuous-Claude-v2: Three-Layer System","text":"<p>Layer 1: Continuity Ledger (within-session) <pre><code>&lt;!-- thoughts/ledgers/CONTINUITY_CLAUDE-myproject.md --&gt;\n## Goal\nImplement payment integration\n\n## State\n- Done: Auth system \u2713\n- Now: Payment webhooks\n- Next: Stripe sandbox tests\n</code></pre></p> <p>Layer 2: Handoffs (between-session) <pre><code>&lt;!-- thoughts/shared/handoffs/session-123/task-1.md --&gt;\n---\nroot_span_id: abc-123\noutcome: PARTIAL_PLUS\n---\n## Context\nWorking on payment webhooks...\n\n## Key Decisions\n- Using Stripe webhooks over polling\n</code></pre></p> <p>Layer 3: Artifact Index (searchable history) <pre><code>-- .claude/cache/artifact-index/context.db (SQLite + FTS5)\nSELECT * FROM handoffs\nWHERE outcome = 'FAILED'\nAND what_failed LIKE '%authentication%'\n</code></pre></p>"},{"location":"comparison/continuous-claude/#fasthooks-dependency-injection","title":"fasthooks: Dependency Injection","text":"<pre><code>from fasthooks.depends import State, Transcript\n\n@app.pre_tool(\"Bash\")\ndef handler(event, state: State, transcript: Transcript):\n    # state: JSON file per session, auto-loaded\n    state[\"command_count\"] = state.get(\"command_count\", 0) + 1\n    state.save()\n\n    # transcript: Parsed history with stats\n    print(f\"Total tokens: {transcript.stats.total_tokens}\")\n</code></pre> Aspect Continuous-Claude fasthooks State format Markdown ledgers JSON dict Persistence File-based (3 layers) File-based (1 layer) Searchable SQLite + FTS5 No built-in search Complexity High (rich context) Low (simple state) Setup Requires directory structure Zero setup"},{"location":"comparison/continuous-claude/#unique-features","title":"Unique Features","text":""},{"location":"comparison/continuous-claude/#continuous-claude-v2","title":"Continuous-Claude-v2","text":"<p>1. TypeScript Preflight <pre><code>// PreToolUse runs tsc --noEmit before Edit/Write on .ts files\nif (checkResult.has_errors) {\n  return { decision: 'block', reason: errorSummary };\n}\n</code></pre> Catches type errors before they're written.</p> <p>2. Skill Auto-Activation <pre><code>// skill-rules.json\n{\n  \"skills\": {\n    \"morph-search\": {\n      \"priority\": \"high\",\n      \"promptTriggers\": {\n        \"keywords\": [\"search\", \"grep\", \"find\"]\n      }\n    }\n  }\n}\n</code></pre> UserPromptSubmit hook suggests skills based on keywords/intent.</p> <p>3. Auto-Handoff on Compact</p> <p>PreCompact hook automatically: 1. Parses transcript 2. Generates handoff with file:line references 3. SessionStart loads it on resume</p> <p>No manual handoff needed.</p> <p>4. Outcome Tracking <pre><code>SUCCEEDED | PARTIAL_PLUS | PARTIAL_MINUS | FAILED\n</code></pre> Mark handoff outcomes, query past failures to improve decisions.</p> <p>5. Context Percentage Warnings</p> <p>Reads <code>/tmp/claude-context-pct-{SESSION}.txt</code>, shows warnings: - &lt;60%: Normal - 60-79%: Yellow warning - 80%+: Red critical</p> <p>6. Pre-bundled Deployment</p> <p>No npm install - just copy <code>.claude/hooks/</code> and run.</p>"},{"location":"comparison/continuous-claude/#fasthooks","title":"fasthooks","text":"<p>1. Response Helpers <pre><code>deny(\"reason\")   # Block with message\nblock(\"reason\")  # Prevent stop\nallow(message=\"...\") # Continue with feedback\n</code></pre></p> <p>2. Dependency Injection <pre><code>def handler(event, state: State, transcript: Transcript, tasks: Tasks):\n    # All dependencies auto-injected\n</code></pre></p> <p>3. Blueprints <pre><code>security = Blueprint()\n\n@security.pre_tool(\"Bash\")\ndef no_sudo(event):\n    ...\n\napp.include(security)\n</code></pre></p> <p>4. Guards <pre><code>@app.pre_tool(\"Bash\", when=lambda e: \"sudo\" in e.command)\ndef check_sudo(event):\n    return deny(\"No sudo\")\n</code></pre></p> <p>5. Background Tasks <pre><code>@task\ndef analyze(code: str) -&gt; str:\n    return expensive_analysis(code)\n\n@app.pre_tool(\"Write\")\ndef on_write(event, tasks: Tasks):\n    tasks.add(analyze, event.content)\n</code></pre></p> <p>6. Testing Utilities <pre><code>client = TestClient(app)\nresponse = client.send(MockEvent.bash(command=\"rm -rf /\"))\nassert response.decision == \"deny\"\n</code></pre></p>"},{"location":"comparison/continuous-claude/#developer-experience","title":"Developer Experience","text":""},{"location":"comparison/continuous-claude/#continuous-claude-v2-typescript-shell","title":"Continuous-Claude-v2: TypeScript + Shell","text":"<pre><code>// .claude/hooks/src/my-hook.ts\nimport { readFileSync } from 'fs';\n\ninterface Input {\n  session_id: string;\n  cwd: string;\n  tool_name: string;\n  tool_input: any;\n}\n\nconst input: Input = JSON.parse(readFileSync('/dev/stdin', 'utf-8'));\n\nif (input.tool_name === 'Bash' &amp;&amp; input.tool_input.command.includes('rm')) {\n  console.log(JSON.stringify({ decision: 'block', reason: 'Blocked' }));\n} else {\n  console.log(JSON.stringify({ continue: true }));\n}\n</code></pre> <pre><code># .claude/hooks/my-hook.sh\n#!/bin/bash\ncd ~/.claude/hooks\ncat | node dist/my-hook.mjs\n</code></pre> <p>Workflow: 1. Edit TypeScript in <code>src/</code> 2. Run <code>./build.sh</code> to compile 3. Test by running hook manually 4. Commit <code>dist/</code> for deployment</p>"},{"location":"comparison/continuous-claude/#fasthooks-pure-python_1","title":"fasthooks: Pure Python","text":"<pre><code># hooks.py\nfrom fasthooks import HookApp, deny\n\napp = HookApp()\n\n@app.pre_tool(\"Bash\")\ndef check_bash(event):\n    if \"rm\" in event.command:\n        return deny(\"Blocked\")\n\nif __name__ == \"__main__\":\n    app.run()\n</code></pre> <p>Workflow: 1. Write Python 2. Run tests with <code>TestClient</code> 3. Deploy</p>"},{"location":"comparison/continuous-claude/#feature-matrix","title":"Feature Matrix","text":"Feature Continuous-Claude fasthooks Hook Framework Partial (specialized) \u2705 (general purpose) Deny/Block PreToolUse only Any event Typed Events TypeScript interfaces Pydantic models Property Accessors Manual (<code>input.tool_input.x</code>) <code>event.command</code> State Persistence \u2705 (3-layer) \u2705 (simple) Transcript Parsing \u2705 (for handoffs) \u2705 (built-in) Background Tasks \u274c \u2705 Blueprints \u274c \u2705 Middleware \u274c \u2705 Guards \u274c \u2705 Testing Utils \u274c \u2705 Skills System \u2705 \u274c TypeScript Preflight \u2705 \u274c Auto-Handoff \u2705 \u274c Outcome Tracking \u2705 \u274c Zero-Config Deploy \u2705 (pre-bundled) Requires pip"},{"location":"comparison/continuous-claude/#when-to-use-each","title":"When to Use Each","text":""},{"location":"comparison/continuous-claude/#use-continuous-claude-v2-when","title":"Use Continuous-Claude-v2 When:","text":"<ul> <li>You want session continuity across <code>/clear</code> and compaction</li> <li>You need ledgers and handoffs for complex multi-session work</li> <li>You want TypeScript type checking before edits</li> <li>You need skill auto-activation based on keywords</li> <li>You want outcome tracking to learn from past sessions</li> <li>You prefer pre-bundled deployment (no pip/npm at runtime)</li> </ul>"},{"location":"comparison/continuous-claude/#use-fasthooks-when","title":"Use fasthooks When:","text":"<ul> <li>You're building custom hooks with any logic</li> <li>You need to block on any event (not just PreToolUse)</li> <li>You want typed events with IDE autocomplete</li> <li>You need dependency injection (State, Transcript, Tasks)</li> <li>You want modular composition (blueprints, middleware)</li> <li>You need easy testing with mock events</li> <li>You want background tasks for async work</li> </ul>"},{"location":"comparison/continuous-claude/#using-both-together","title":"Using Both Together","text":"<p>The systems serve different purposes and can coexist:</p> <pre><code>{\n  \"hooks\": {\n    \"SessionStart\": [\n      { \"command\": \"~/.claude/hooks/session-start.sh\" }\n    ],\n    \"PreToolUse\": [\n      { \"command\": \"python /path/to/fasthooks/security.py\" },\n      { \"command\": \"~/.claude/hooks/typescript-preflight.sh\" }\n    ],\n    \"PostToolUse\": [\n      { \"command\": \"~/.claude/hooks/handoff-index.sh\" }\n    ],\n    \"PreCompact\": [\n      { \"command\": \"~/.claude/hooks/pre-compact.sh\" }\n    ]\n  }\n}\n</code></pre> <ul> <li>Continuous-Claude for session continuity (ledgers, handoffs, context injection)</li> <li>fasthooks for policy enforcement (security, rate limiting, custom logic)</li> </ul>"},{"location":"comparison/continuous-claude/#summary","title":"Summary","text":"Aspect Continuous-Claude-v2 fasthooks What It Is Session continuity system Hook framework Philosophy Preserve context across clears Build custom hook logic Best For Long-running projects Custom policies Language TypeScript + Shell Python Blocking PreToolUse only Any event Complexity High (rich features) Low (simple API) Dependencies Pre-bundled (none) pip install"},{"location":"tutorial/","title":"Tutorial","text":"<p>Learn fasthooks step by step.</p>"},{"location":"tutorial/#overview","title":"Overview","text":"<p>This tutorial covers:</p> <ol> <li>Events - Understanding hook events and typed tool events</li> <li>Responses - Using <code>allow()</code>, <code>deny()</code>, and <code>block()</code></li> <li>Dependencies - Inject State and Transcript into handlers</li> <li>Transcript - Context engineering and memory editing</li> <li>Background Tasks - Spawn async work that feeds back later</li> <li>Blueprints - Organize handlers into reusable modules</li> <li>Middleware - Cross-cutting concerns (timing, logging)</li> <li>Testing - Writing tests with <code>MockEvent</code> and <code>TestClient</code></li> </ol>"},{"location":"tutorial/#core-concepts","title":"Core Concepts","text":""},{"location":"tutorial/#hookapp","title":"HookApp","text":"<p>The main class that registers and runs your handlers:</p> <pre><code>from fasthooks import HookApp\n\napp = HookApp()\n\n@app.pre_tool(\"Bash\")\ndef my_handler(event):\n    ...\n\nif __name__ == \"__main__\":\n    app.run()\n</code></pre>"},{"location":"tutorial/#decorators","title":"Decorators","text":"<p>Register handlers for different hook events:</p> Decorator When it runs <code>@app.pre_tool(\"Bash\")</code> Before a tool executes <code>@app.post_tool(\"Write\")</code> After a tool executes <code>@app.on_stop()</code> When Claude stops <code>@app.on_session_start()</code> When a session starts"},{"location":"tutorial/#typed-events","title":"Typed Events","text":"<p>Each tool has typed event with autocomplete:</p> <pre><code>@app.pre_tool(\"Bash\")\ndef check(event):\n    print(event.command)      # str\n    print(event.description)  # str | None\n    print(event.timeout)      # int | None\n</code></pre>"},{"location":"tutorial/#guards","title":"Guards","text":"<p>Filter which events trigger your handler:</p> <pre><code>@app.pre_tool(\"Bash\", when=lambda e: \"sudo\" in e.command)\ndef check_sudo(event):\n    return deny(\"No sudo allowed\")\n</code></pre>"},{"location":"tutorial/#advanced-topics","title":"Advanced Topics","text":"<ul> <li>Dependencies - Access conversation history and persistent state</li> <li>Background Tasks - Async work with Claude sub-agents</li> <li>Blueprints - Split handlers into reusable modules</li> <li>Middleware - Add timing, logging, error handling to all handlers</li> </ul>"},{"location":"tutorial/background-tasks/","title":"Background Tasks","text":"<p>Background tasks let you spawn async work that runs independently and feeds back results in subsequent hook calls. This is perfect for:</p> <ul> <li>Long-running computations (code analysis, linting)</li> <li>API calls that shouldn't block the hook</li> <li>Claude sub-agents for AI-powered analysis</li> <li>Memory lookup across sessions</li> </ul>"},{"location":"tutorial/background-tasks/#quick-start","title":"Quick Start","text":"<pre><code>from fasthooks import HookApp, allow\nfrom fasthooks.tasks import task, Tasks\n\n# Define a task\n@task\ndef analyze_code(code: str) -&gt; str:\n    # This runs in a thread pool\n    import time\n    time.sleep(2)  # Simulate long operation\n    return f\"Analysis complete: {len(code)} chars\"\n\napp = HookApp()\n\n# Spawn task when code is written\n@app.pre_tool(\"Write\")\ndef on_write(event, tasks: Tasks):\n    tasks.add(analyze_code, event.content)\n    return allow()\n\n# Check for results on next prompt (same dependency)\n@app.on_prompt()\ndef check_results(event, tasks: Tasks):\n    if result := tasks.pop(analyze_code):\n        return allow(message=f\"Previous analysis: {result}\")\n    return allow()\n</code></pre>"},{"location":"tutorial/background-tasks/#how-it-works","title":"How It Works","text":"<p>All task operations are non-blocking:</p> Method Behavior <code>tasks.add()</code> Submits to thread pool, returns immediately <code>tasks.pop()</code> Dict lookup, returns result or <code>None</code> instantly <code>tasks.get()</code> Dict lookup, returns <code>TaskResult</code> or <code>None</code> instantly <code>tasks.has()</code> Dict lookup, returns <code>bool</code> instantly <code>await tasks.wait()</code> Async polling, yields while waiting <p>The pattern is fire-and-forget:</p> <pre><code>Hook 1: tasks.add(my_task, args)  \u2192  queues work  \u2192  returns instantly\n        \u2193\n        ThreadPoolExecutor runs task in background\n        \u2193\nHook 2: tasks.pop(my_task)  \u2192  checks dict  \u2192  returns result (or None if still running)\n</code></pre> <p>This design ensures hooks never block on IO-bound work like API calls or database queries.</p>"},{"location":"tutorial/background-tasks/#core-concepts","title":"Core Concepts","text":""},{"location":"tutorial/background-tasks/#task-definition","title":"Task Definition","text":"<p>Use <code>@task</code> to define a background task:</p> <pre><code>from fasthooks.tasks import task\n\n@task\ndef simple_task(x: int) -&gt; int:\n    return x * 2\n\n# With options\n@task(ttl=600, priority=5)\ndef important_task(query: str) -&gt; str:\n    return search_db(query)\n\n# With result transformation\n@task(transform=lambda r: r[:500])\ndef long_output_task() -&gt; str:\n    return very_long_string()\n</code></pre> <p>Options:</p> Option Default Description <code>ttl</code> 300 Time-to-live in seconds for the result <code>priority</code> 0 Higher priority tasks may be scheduled first <code>transform</code> None Function to transform the result"},{"location":"tutorial/background-tasks/#tasks-recommended","title":"Tasks (recommended)","text":"<p>Inject <code>Tasks</code> to spawn tasks and retrieve results:</p> <pre><code>from fasthooks.tasks import Tasks\n\n@app.pre_tool(\"Write\")\ndef on_write(event, tasks: Tasks):\n    # Add a task (default key = function name)\n    tasks.add(my_task, arg1, arg2)\n\n    # Add with custom TTL\n    tasks.add(other_task, data, ttl=600)\n\n    return allow()\n</code></pre> <p>For multiple concurrent calls to the same function, provide an explicit <code>key</code>:</p> <pre><code>tasks.add(fetch, \"https://example.com/a\", key=\"fetch:a\")\ntasks.add(fetch, \"https://example.com/b\", key=\"fetch:b\")\n</code></pre> <p>Methods:</p> Method Description <code>add(func, *args, key=None, ttl=300, **kwargs)</code> Enqueue a task <code>cancel(key)</code> Cancel a pending/running task <code>cancel_all()</code> Cancel all tasks for this session <code>get(key)</code> Get TaskResult without removing <code>pop(key)</code> Pop completed result value <code>pop_all()</code> Pop all completed results <code>pop_errors()</code> Pop failed tasks as <code>[(key, exception), ...]</code> <code>has(key=None)</code> Check if results are ready <p><code>BackgroundTasks</code> and <code>PendingResults</code> are still available for a split enqueue/results model, but <code>Tasks</code> is the recommended DX.</p>"},{"location":"tutorial/background-tasks/#async-waiting","title":"Async Waiting","text":"<p>For handlers that need to wait for results:</p> <pre><code>@app.on_stop()\nasync def wait_for_results(event, tasks: Tasks):\n    # Wait for specific task (with timeout)\n    result = await tasks.wait(\"analysis\", timeout=10.0)\n\n    # Wait for multiple tasks\n    results = await tasks.wait_all([\"task1\", \"task2\"], timeout=30.0)\n\n    # Wait for any task to complete\n    completed = await tasks.wait_any([\"task1\", \"task2\"])\n    if completed:\n        key, result = completed\n\n    return allow()\n</code></pre>"},{"location":"tutorial/background-tasks/#claude-sub-agents","title":"Claude Sub-Agents","text":"<p>Use the Claude Agent SDK for AI-powered background tasks:</p> <pre><code>pip install fasthooks[claude]\n</code></pre>"},{"location":"tutorial/background-tasks/#claudeagent","title":"ClaudeAgent","text":"<p>Simple wrapper for querying Claude:</p> <pre><code>from fasthooks.contrib.claude import ClaudeAgent\n\nagent = ClaudeAgent(\n    model=\"haiku\",              # haiku, sonnet, opus\n    system_prompt=\"You are helpful.\",\n    allowed_tools=[\"Read\", \"Grep\"],\n    max_turns=5,\n    max_budget_usd=0.10,\n)\n\n# Simple query\nresponse = await agent.query(\"What is 2+2?\")\n\n# Override options per-query\nresponse = await agent.query(\n    \"Analyze this code\",\n    system_prompt=\"You are a code reviewer.\",\n    max_turns=3,\n)\n</code></pre>"},{"location":"tutorial/background-tasks/#agent_task-decorator","title":"@agent_task Decorator","text":"<p>Create background tasks that use Claude:</p> <pre><code>from fasthooks.contrib.claude import ClaudeAgent, agent_task\nfrom fasthooks.tasks import Tasks\n\n@agent_task(model=\"haiku\", system_prompt=\"You review code for security issues.\")\nasync def security_review(agent: ClaudeAgent, code: str) -&gt; str:\n    return await agent.query(f\"Review for security:\\n{code}\")\n\n@agent_task(model=\"sonnet\", allowed_tools=[\"Read\", \"Grep\"])\nasync def codebase_search(agent: ClaudeAgent, query: str) -&gt; str:\n    return await agent.query(f\"Search the codebase for: {query}\")\n\n@app.pre_tool(\"Write\")\ndef on_write(event, tasks: Tasks):\n    tasks.add(security_review, event.content)\n    return allow()\n</code></pre> <p>The agent is automatically injected as the first argument.</p>"},{"location":"tutorial/background-tasks/#use-cases","title":"Use Cases","text":""},{"location":"tutorial/background-tasks/#code-review-agent","title":"Code Review Agent","text":"<pre><code>from fasthooks.contrib.claude import ClaudeAgent, agent_task\n\n@agent_task(\n    model=\"sonnet\",\n    system_prompt=\"\"\"You are a code reviewer. Check for:\n    - Security vulnerabilities\n    - Performance issues\n    - Code style problems\n    Respond with a brief summary.\"\"\"\n)\nasync def review_code(agent: ClaudeAgent, code: str, file_path: str) -&gt; str:\n    return await agent.query(f\"Review {file_path}:\\n```\\n{code}\\n```\")\n\n@app.pre_tool(\"Write\")\ndef on_write(event, tasks: Tasks):\n    if event.file_path.endswith(\".py\"):\n        tasks.add(review_code, event.content, event.file_path)\n    return allow()\n\n@app.on_prompt()\ndef show_review(event, tasks: Tasks):\n    if review := tasks.pop(review_code):\n        return allow(message=f\"Code review:\\n{review}\")\n    return allow()\n</code></pre>"},{"location":"tutorial/background-tasks/#memorycontext-lookup","title":"Memory/Context Lookup","text":"<pre><code>@task\ndef search_memory(query: str, session_id: str) -&gt; str:\n    # Search vector DB, knowledge base, etc.\n    results = vector_db.search(query, filter={\"session\": session_id})\n    return \"\\n\".join(r.text for r in results[:3])\n\n@app.on_prompt()\ndef enrich_prompt(event, tasks: Tasks):\n    # Check for previous search results\n    if context := tasks.pop(search_memory):\n        return allow(message=f\"Relevant context:\\n{context}\")\n\n    # Start new search based on prompt\n    tasks.add(search_memory, event.prompt, event.session_id)\n    return allow()\n</code></pre>"},{"location":"tutorial/background-tasks/#rate-limited-api-calls","title":"Rate-Limited API Calls","text":"<pre><code>import httpx\n\n@task(ttl=600)  # Cache for 10 minutes\ndef fetch_documentation(url: str) -&gt; str:\n    response = httpx.get(url)\n    return response.text[:5000]\n\n@app.pre_tool(\"WebFetch\")\ndef prefetch_docs(event, tasks: Tasks):\n    # Start fetching in background\n    tasks.add(fetch_documentation, event.url, key=f\"doc:{event.url}\")\n    return allow()\n</code></pre>"},{"location":"tutorial/background-tasks/#testing","title":"Testing","text":"<p>Use <code>ImmediateBackend</code> for synchronous testing:</p> <pre><code>from fasthooks.tasks import task, Tasks\nfrom fasthooks.tasks.testing import ImmediateBackend\n\n@task\ndef double(x: int) -&gt; int:\n    return x * 2\n\ndef test_background_task():\n    backend = ImmediateBackend()\n\n    tasks = Tasks(backend, session_id=\"test\")\n    tasks.add(double, 5)\n    assert tasks.pop(double) == 10\n</code></pre>"},{"location":"tutorial/background-tasks/#error-handling","title":"Error Handling","text":"<p>Tasks that fail store their exceptions:</p> <pre><code>@task\ndef risky_task() -&gt; str:\n    raise ValueError(\"Something went wrong\")\n\n@app.on_prompt()\ndef check_errors(event, tasks: Tasks):\n    # Pop all failed tasks\n    for key, error in tasks.pop_errors():\n        print(f\"Task {key} failed: {error}\")\n    return allow()\n</code></pre>"},{"location":"tutorial/background-tasks/#task-status","title":"Task Status","text":"<p>Check detailed task status via <code>TaskResult</code>:</p> <pre><code>from fasthooks.tasks import TaskStatus\n\n@app.on_prompt()\ndef check_status(event, tasks: Tasks):\n    result = tasks.get(\"my-task\")\n    if result:\n        if result.status == TaskStatus.COMPLETED:\n            print(f\"Done: {result.value}\")\n        elif result.status == TaskStatus.RUNNING:\n            print(\"Still running...\")\n        elif result.status == TaskStatus.FAILED:\n            print(f\"Error: {result.error}\")\n    return allow()\n</code></pre> <p>Status values:</p> Status Description <code>PENDING</code> Queued, not started <code>RUNNING</code> Currently executing <code>COMPLETED</code> Finished successfully <code>FAILED</code> Exception raised <code>CANCELLED</code> Cancelled by user"},{"location":"tutorial/blueprints/","title":"Blueprints","text":"<p>Blueprints let you organize handlers into reusable, composable modules.</p>"},{"location":"tutorial/blueprints/#why-blueprints","title":"Why Blueprints?","text":"<p>As your hooks grow, a single file becomes hard to manage:</p> <pre><code># hooks.py - getting messy!\n@app.pre_tool(\"Bash\")\ndef security_check(event): ...\n\n@app.pre_tool(\"Write\")\ndef security_write(event): ...\n\n@app.pre_tool(\"Bash\")\ndef logging_bash(event): ...\n\n@app.post_tool(\"Write\")\ndef logging_write(event): ...\n\n@app.on_stop()\ndef cleanup(event): ...\n</code></pre> <p>Blueprints let you split by concern:</p> <pre><code>hooks/\n\u251c\u2500\u2500 __init__.py      # Main app\n\u251c\u2500\u2500 security.py      # Security rules\n\u251c\u2500\u2500 logging.py       # Audit logging\n\u2514\u2500\u2500 cleanup.py       # Session cleanup\n</code></pre>"},{"location":"tutorial/blueprints/#basic-usage","title":"Basic Usage","text":"<pre><code># security.py\nfrom fasthooks import Blueprint, deny\n\nsecurity = Blueprint(\"security\")\n\n@security.pre_tool(\"Bash\")\ndef no_dangerous_commands(event):\n    if \"rm -rf\" in event.command:\n        return deny(\"Dangerous command blocked\")\n\n@security.pre_tool(\"Write\")\ndef protect_sensitive_files(event):\n    if \".env\" in event.file_path:\n        return deny(\"Cannot modify .env files\")\n</code></pre> <pre><code># hooks.py\nfrom fasthooks import HookApp\nfrom security import security\n\napp = HookApp()\napp.include(security)\n\nif __name__ == \"__main__\":\n    app.run()\n</code></pre>"},{"location":"tutorial/blueprints/#blueprint-api","title":"Blueprint API","text":"<p>Blueprints support the same decorators as HookApp:</p> <pre><code>from fasthooks import Blueprint\n\nbp = Blueprint(\"my-blueprint\")\n\n# Tool events\n@bp.pre_tool(\"Bash\")\ndef check(event): ...\n\n@bp.post_tool(\"Write\")\ndef after(event): ...\n\n@bp.on_permission(\"Bash\")\ndef perm(event): ...\n\n# Lifecycle events\n@bp.on_stop()\ndef stop(event): ...\n\n@bp.on_session_start()\ndef start(event): ...\n</code></pre>"},{"location":"tutorial/blueprints/#real-world-examples","title":"Real-World Examples","text":""},{"location":"tutorial/blueprints/#security-blueprint","title":"Security Blueprint","text":"<pre><code># blueprints/security.py\nfrom fasthooks import Blueprint, deny\n\nsecurity = Blueprint(\"security\")\n\nDANGEROUS_PATTERNS = [\n    \"rm -rf\",\n    \"mkfs\",\n    \"&gt; /dev/sd\",\n    \"dd if=\",\n]\n\nPROTECTED_PATHS = [\n    \".env\",\n    \".ssh\",\n    \"credentials\",\n    \"secrets\",\n]\n\n@security.pre_tool(\"Bash\")\ndef block_dangerous_commands(event):\n    for pattern in DANGEROUS_PATTERNS:\n        if pattern in event.command:\n            return deny(f\"Blocked: contains '{pattern}'\")\n\n@security.pre_tool(\"Write\")\ndef protect_files(event):\n    for path in PROTECTED_PATHS:\n        if path in event.file_path:\n            return deny(f\"Cannot write to {path}\")\n\n@security.pre_tool(\"Edit\")\ndef protect_edits(event):\n    for path in PROTECTED_PATHS:\n        if path in event.file_path:\n            return deny(f\"Cannot edit {path}\")\n</code></pre>"},{"location":"tutorial/blueprints/#logging-blueprint","title":"Logging Blueprint","text":"<pre><code># blueprints/logging.py\nfrom fasthooks import Blueprint\nfrom fasthooks.depends import State\nfrom datetime import datetime\n\nlogging = Blueprint(\"logging\")\n\n@logging.post_tool(\"Bash\")\ndef log_bash(event, state: State):\n    logs = state.get(\"bash_log\", [])\n    logs.append({\n        \"command\": event.command,\n        \"time\": datetime.now().isoformat(),\n    })\n    state[\"bash_log\"] = logs[-100:]  # Keep last 100\n    state.save()\n\n@logging.post_tool(\"Write\")\ndef log_write(event, state: State):\n    logs = state.get(\"write_log\", [])\n    logs.append({\n        \"file\": event.file_path,\n        \"time\": datetime.now().isoformat(),\n    })\n    state[\"write_log\"] = logs[-100:]\n    state.save()\n</code></pre>"},{"location":"tutorial/blueprints/#rate-limiting-blueprint","title":"Rate Limiting Blueprint","text":"<pre><code># blueprints/rate_limit.py\nfrom fasthooks import Blueprint, deny\nfrom fasthooks.depends import State\n\nrate_limit = Blueprint(\"rate-limit\")\n\nLIMITS = {\n    \"Bash\": 100,\n    \"Write\": 50,\n    \"Edit\": 50,\n}\n\n@rate_limit.pre_tool(\"*\")\ndef check_rate(event, state: State):\n    tool = event.tool_name\n    if tool not in LIMITS:\n        return\n\n    key = f\"rate_{tool}\"\n    count = state.get(key, 0) + 1\n    state[key] = count\n    state.save()\n\n    limit = LIMITS[tool]\n    if count &gt; limit:\n        return deny(f\"Rate limit exceeded: {count}/{limit} {tool} calls\")\n</code></pre>"},{"location":"tutorial/blueprints/#composing-multiple-blueprints","title":"Composing Multiple Blueprints","text":"<pre><code># hooks.py\nfrom fasthooks import HookApp\nfrom blueprints.security import security\nfrom blueprints.logging import logging\nfrom blueprints.rate_limit import rate_limit\n\napp = HookApp(state_dir=\"/tmp/fasthooks-state\")\n\n# Include all blueprints\napp.include(security)\napp.include(logging)\napp.include(rate_limit)\n\n# Add app-specific handlers\n@app.on_stop()\ndef final_check(event):\n    ...\n\nif __name__ == \"__main__\":\n    app.run()\n</code></pre>"},{"location":"tutorial/blueprints/#when-to-use-blueprints","title":"When to Use Blueprints","text":"Scenario Blueprint? Single file with &lt;10 handlers No Handlers grouped by concern (security, logging) Yes Reusable rules across projects Yes Team members working on different features Yes Conditionally enabling feature sets Yes"},{"location":"tutorial/blueprints/#blueprint-vs-middleware","title":"Blueprint vs Middleware","text":"<ul> <li>Blueprints: Organize handlers by feature/concern</li> <li>Middleware: Cross-cutting logic that wraps ALL handlers</li> </ul> <p>Use blueprints when you want modular organization. Use middleware when you want universal behavior (timing, logging every call).</p>"},{"location":"tutorial/dependencies/","title":"Dependency Injection","text":"<p>fasthooks automatically injects dependencies into your handlers based on type hints. This gives you access to conversation history, persistent state, and more.</p>"},{"location":"tutorial/dependencies/#why-dependency-injection","title":"Why Dependency Injection?","text":"<p>Without DI, your handler only sees the current event:</p> <pre><code>@app.pre_tool(\"Bash\")\ndef check(event):\n    # Only know about THIS bash command\n    # No context about what happened before\n    pass\n</code></pre> <p>With DI, you get full conversation context:</p> <pre><code>@app.pre_tool(\"Bash\")\ndef check(event, transcript: Transcript, state: State):\n    # transcript: Full conversation history, token counts, all tool calls\n    # state: Persistent dict that survives between hook invocations\n    pass\n</code></pre>"},{"location":"tutorial/dependencies/#available-dependencies","title":"Available Dependencies","text":"Dependency Description <code>Transcript</code> Conversation history and statistics <code>State</code> Persistent session-scoped storage <code>Tasks</code> Background task enqueue + results"},{"location":"tutorial/dependencies/#transcript","title":"Transcript","text":"<p>Access the full conversation history. Lazy-loaded and cached - no performance penalty if unused.</p> <pre><code>from fasthooks.depends import Transcript\n\n@app.pre_tool(\"Bash\")\ndef check(event, transcript: Transcript):\n    stats = transcript.stats\n\n    # Token usage\n    print(f\"Tokens: {stats.input_tokens} in / {stats.output_tokens} out\")\n\n    # Tool usage\n    print(f\"Tool calls: {stats.tool_calls}\")  # {\"Bash\": 5, \"Write\": 2}\n    print(f\"Errors: {stats.error_count}\")\n\n    # Entries\n    print(f\"Messages: {len(transcript.entries)}\")\n    print(f\"Turns: {stats.turn_count}\")\n</code></pre> <p>The Transcript provides rich querying, CRUD operations, and context engineering capabilities.</p> <p>See Transcript &amp; Context Engineering for full documentation.</p> <p>Quick overview:</p> Feature Example Query entries <code>transcript.query().assistants().with_tools().all()</code> Statistics <code>transcript.stats.input_tokens</code> Create entries <code>UserMessage.create(\"reminder\", context=entry)</code> Inject tool results <code>inject_tool_result(transcript, \"Bash\", {...}, \"output\")</code> Export <code>transcript.to_markdown()</code>, <code>transcript.to_file(\"out.md\")</code>"},{"location":"tutorial/dependencies/#state","title":"State","text":"<p>Persistent dict that survives between hook invocations. Backed by a JSON file.</p> <pre><code>from fasthooks.depends import State\n\n# Enable state by configuring state_dir\napp = HookApp(state_dir=\"/tmp/fasthooks-state\")\n\n@app.pre_tool(\"Bash\")\ndef rate_limit(event, state: State):\n    # Count commands per session\n    count = state.get(\"bash_count\", 0) + 1\n    state[\"bash_count\"] = count\n    state.save()  # Persist to disk\n\n    if count &gt; 100:\n        return deny(\"Too many bash commands in this session\")\n</code></pre>"},{"location":"tutorial/dependencies/#state-methods","title":"State Methods","text":"Method Description <code>state.save()</code> Persist to disk <code>state.get(key, default)</code> Get with default <code>state[key] = value</code> Set value <code>key in state</code> Check existence <p>State is scoped to the session - each session gets its own JSON file.</p>"},{"location":"tutorial/dependencies/#tasks","title":"Tasks","text":"<p>Enqueue background tasks and retrieve results. See Background Tasks for full details.</p> <pre><code>from fasthooks.tasks import Tasks\n\n@app.pre_tool(\"Write\")\ndef on_write(event, tasks: Tasks):\n    # Enqueue (key defaults to function name)\n    tasks.add(analyze_code, event.content)\n\n@app.on_prompt()\ndef check(event, tasks: Tasks):\n    # Pop by function reference\n    if result := tasks.pop(analyze_code):\n        return allow(message=f\"Analysis: {result}\")\n</code></pre>"},{"location":"tutorial/dependencies/#use-cases","title":"Use Cases","text":""},{"location":"tutorial/dependencies/#rate-limiting","title":"Rate Limiting","text":"<pre><code>@app.pre_tool(\"Bash\")\ndef rate_limit(event, state: State):\n    count = state.get(\"commands\", 0) + 1\n    state[\"commands\"] = count\n    state.save()\n\n    if count &gt; 50:\n        return deny(f\"Rate limit: {count}/50 commands used\")\n</code></pre>"},{"location":"tutorial/dependencies/#token-budget","title":"Token Budget","text":"<pre><code>@app.on_stop()\ndef check_budget(event, transcript: Transcript):\n    stats = transcript.stats\n    total = stats.input_tokens + stats.output_tokens\n\n    if total &gt; 100_000:\n        return allow(message=f\"Warning: {total:,} tokens used\")\n</code></pre>"},{"location":"tutorial/dependencies/#command-history-analysis","title":"Command History Analysis","text":"<pre><code>@app.pre_tool(\"Bash\")\ndef no_repeated_failures(event, transcript: Transcript):\n    # Query recent Bash tool uses\n    recent = transcript.query().tool_uses(\"Bash\").last(5).all()\n    recent_commands = [e.tool_input.get(\"command\") for e in recent]\n    if event.command in recent_commands:\n        return deny(\"This command was already tried recently\")\n</code></pre>"},{"location":"tutorial/dependencies/#audit-logging","title":"Audit Logging","text":"<pre><code>@app.post_tool(\"Write\")\ndef audit_writes(event, state: State):\n    writes = state.get(\"writes\", [])\n    writes.append({\n        \"file\": event.file_path,\n        \"time\": datetime.now().isoformat(),\n    })\n    state[\"writes\"] = writes\n    state.save()\n</code></pre>"},{"location":"tutorial/dependencies/#context-aware-decisions","title":"Context-Aware Decisions","text":"<pre><code>@app.pre_tool(\"Bash\")\ndef context_check(event, transcript: Transcript):\n    stats = transcript.stats\n\n    # More permissive if user has been working a while\n    if stats.duration_seconds &gt; 3600:  # 1 hour\n        return allow()\n\n    # Stricter for new sessions\n    if \"rm\" in event.command:\n        return deny(\"Destructive commands require established session\")\n</code></pre>"},{"location":"tutorial/dependencies/#how-it-works","title":"How It Works","text":"<ol> <li>fasthooks inspects your handler's type hints</li> <li>For each <code>Transcript</code> or <code>State</code> parameter, it creates the dependency</li> <li>Dependencies are passed when calling your handler</li> </ol> <pre><code># fasthooks sees: def check(event, transcript: Transcript, state: State)\n# And calls: check(event, transcript=Transcript(...), state=State(...))\n</code></pre> <p>Dependencies are created fresh for each hook invocation, but: - <code>Transcript</code> lazily loads and caches parsed data - <code>State</code> loads from disk and persists on <code>.save()</code></p>"},{"location":"tutorial/events/","title":"Events","text":"<p>Claude Code sends different events to your hooks. fasthooks provides typed classes for each.</p>"},{"location":"tutorial/events/#hook-event-types","title":"Hook Event Types","text":""},{"location":"tutorial/events/#pretooluse","title":"PreToolUse","text":"<p>Runs before a tool executes. Can allow, deny, or modify the tool call.</p> <pre><code>@app.pre_tool(\"Bash\")\ndef check_bash(event):\n    if \"rm -rf\" in event.command:\n        return deny(\"Blocked dangerous command\")\n</code></pre>"},{"location":"tutorial/events/#posttooluse","title":"PostToolUse","text":"<p>Runs after a tool executes successfully. Can provide feedback to Claude.</p> <pre><code>@app.post_tool(\"Write\")\ndef after_write(event):\n    # event.tool_response contains the result\n    if event.tool_response.get(\"success\"):\n        print(f\"Wrote to {event.file_path}\")\n</code></pre>"},{"location":"tutorial/events/#permissionrequest","title":"PermissionRequest","text":"<p>Runs when Claude asks for permission. Can auto-allow or auto-deny.</p> <pre><code>@app.on_permission(\"Bash\")\ndef auto_allow_safe(event):\n    if event.command.startswith(\"ls\"):\n        return allow()  # Auto-approve ls commands\n</code></pre>"},{"location":"tutorial/events/#stop-subagentstop","title":"Stop / SubagentStop","text":"<p>Runs when Claude (or a subagent) is about to stop.</p> <pre><code>@app.on_stop()\ndef on_stop(event):\n    if event.stop_hook_active:\n        return allow()  # Prevent infinite loops\n    # Check if work is complete...\n    return block(\"Please run the tests first\")\n</code></pre>"},{"location":"tutorial/events/#sessionstart-sessionend","title":"SessionStart / SessionEnd","text":"<p>Runs at session lifecycle events.</p> <pre><code>@app.on_session_start()\ndef on_start(event):\n    print(f\"Session started: {event.source}\")  # startup, resume, clear\n</code></pre>"},{"location":"tutorial/events/#tool-events","title":"Tool Events","text":"<p>Each tool has a typed event class with specific properties.</p>"},{"location":"tutorial/events/#bash","title":"Bash","text":"<pre><code>@app.pre_tool(\"Bash\")\ndef check(event):\n    event.command      # str - the command to run\n    event.description  # str | None - optional description\n    event.timeout      # int | None - timeout in ms\n</code></pre>"},{"location":"tutorial/events/#write","title":"Write","text":"<pre><code>@app.pre_tool(\"Write\")\ndef check(event):\n    event.file_path  # str - path to write\n    event.content    # str - file content\n</code></pre>"},{"location":"tutorial/events/#edit","title":"Edit","text":"<pre><code>@app.pre_tool(\"Edit\")\ndef check(event):\n    event.file_path   # str - path to edit\n    event.old_string  # str - text to find\n    event.new_string  # str - replacement text\n</code></pre>"},{"location":"tutorial/events/#read","title":"Read","text":"<pre><code>@app.pre_tool(\"Read\")\ndef check(event):\n    event.file_path  # str - path to read\n    event.offset     # int | None - line offset\n    event.limit      # int | None - line limit\n</code></pre>"},{"location":"tutorial/events/#grep-glob","title":"Grep / Glob","text":"<pre><code>@app.pre_tool(\"Grep\")\ndef check(event):\n    event.pattern  # str - search pattern\n    event.path     # str | None - search path\n</code></pre>"},{"location":"tutorial/events/#catch-all-handlers","title":"Catch-All Handlers","text":"<p>Use <code>\"*\"</code> or omit the tool name to match all tools:</p> <pre><code>@app.pre_tool(\"*\")\ndef log_all(event):\n    print(f\"Tool: {event.tool_name}\")\n\n# Or without argument\n@app.pre_tool()\ndef log_all(event):\n    print(f\"Tool: {event.tool_name}\")\n</code></pre>"},{"location":"tutorial/events/#common-fields","title":"Common Fields","text":"<p>All events have these fields:</p> <pre><code>event.session_id       # str - session identifier\nevent.cwd              # str - current working directory\nevent.permission_mode  # str - default, plan, acceptEdits, bypassPermissions\nevent.transcript_path  # str | None - path to conversation JSON\n</code></pre> <p>Tool events also have:</p> <pre><code>event.tool_name     # str - Bash, Write, Edit, etc.\nevent.tool_input    # dict - raw input parameters\nevent.tool_use_id   # str - unique tool call ID\n</code></pre>"},{"location":"tutorial/middleware/","title":"Middleware","text":"<p>Middleware wraps ALL handler calls, letting you add cross-cutting behavior like timing, logging, or error handling.</p>"},{"location":"tutorial/middleware/#why-middleware","title":"Why Middleware?","text":"<p>Some behaviors should apply to every handler:</p> <ul> <li>Timing how long handlers take</li> <li>Logging all events</li> <li>Error handling and recovery</li> <li>Authentication/authorization</li> </ul> <p>Without middleware, you'd duplicate this in every handler:</p> <pre><code>@app.pre_tool(\"Bash\")\ndef check_bash(event):\n    start = time.time()\n    try:\n        result = do_check(event)\n        logger.info(f\"Bash check took {time.time() - start:.3f}s\")\n        return result\n    except Exception as e:\n        logger.error(f\"Error: {e}\")\n        raise\n\n# Repeat for every handler... \ud83d\ude29\n</code></pre> <p>With middleware:</p> <pre><code>@app.middleware\ndef timing(event, call_next):\n    start = time.time()\n    result = call_next(event)\n    print(f\"Handlers took {time.time() - start:.3f}s\")\n    return result\n\n# Automatically wraps ALL handlers \u2728\n</code></pre>"},{"location":"tutorial/middleware/#basic-usage","title":"Basic Usage","text":"<pre><code>from fasthooks import HookApp\n\napp = HookApp()\n\n@app.middleware\ndef my_middleware(event, call_next):\n    # Before handlers\n    print(f\"Processing {event.hook_event_name}\")\n\n    # Call the handler chain\n    result = call_next(event)\n\n    # After handlers\n    print(f\"Result: {result}\")\n\n    return result\n</code></pre>"},{"location":"tutorial/middleware/#how-it-works","title":"How It Works","text":"<pre><code>Event \u2192 Middleware 1 \u2192 Middleware 2 \u2192 ... \u2192 Handlers \u2192 Response\n              \u2193              \u2193                  \u2193\n          call_next      call_next          execute\n</code></pre> <ol> <li>Event enters the middleware chain</li> <li>Each middleware calls <code>call_next(event)</code> to continue</li> <li>Handlers execute and return a response</li> <li>Response bubbles back through middleware</li> <li>Final response returned</li> </ol>"},{"location":"tutorial/middleware/#common-patterns","title":"Common Patterns","text":""},{"location":"tutorial/middleware/#timing","title":"Timing","text":"<pre><code>import time\n\n@app.middleware\ndef timing(event, call_next):\n    start = time.time()\n    result = call_next(event)\n    elapsed = time.time() - start\n    print(f\"[{event.hook_event_name}] {elapsed:.3f}s\")\n    return result\n</code></pre>"},{"location":"tutorial/middleware/#logging","title":"Logging","text":"<pre><code>import logging\n\nlogger = logging.getLogger(\"hooks\")\n\n@app.middleware\ndef log_events(event, call_next):\n    logger.info(f\"Event: {event.hook_event_name}\")\n    if hasattr(event, \"tool_name\"):\n        logger.info(f\"Tool: {event.tool_name}\")\n\n    result = call_next(event)\n\n    if result:\n        logger.info(f\"Decision: {result.decision}\")\n\n    return result\n</code></pre>"},{"location":"tutorial/middleware/#error-handling","title":"Error Handling","text":"<pre><code>@app.middleware\ndef error_handler(event, call_next):\n    try:\n        return call_next(event)\n    except Exception as e:\n        print(f\"Handler error: {e}\")\n        # Return None to allow (fail-open)\n        # Or return deny(\"Internal error\") to fail-closed\n        return None\n</code></pre>"},{"location":"tutorial/middleware/#conditional-processing","title":"Conditional Processing","text":"<pre><code>@app.middleware\ndef skip_in_plan_mode(event, call_next):\n    # Skip all checks in plan mode\n    if event.permission_mode == \"plan\":\n        return None\n\n    return call_next(event)\n</code></pre>"},{"location":"tutorial/middleware/#response-modification","title":"Response Modification","text":"<pre><code>@app.middleware\ndef add_warnings(event, call_next):\n    result = call_next(event)\n\n    # Add warning to all denials\n    if result and result.decision == \"deny\":\n        result.message = f\"\u26a0\ufe0f Blocked: {result.reason}\"\n\n    return result\n</code></pre>"},{"location":"tutorial/middleware/#async-middleware","title":"Async Middleware","text":"<p>Middleware can be async:</p> <pre><code>@app.middleware\nasync def async_middleware(event, call_next):\n    # Async operations allowed\n    await some_async_check()\n\n    result = await call_next(event)\n\n    return result\n</code></pre>"},{"location":"tutorial/middleware/#multiple-middleware","title":"Multiple Middleware","text":"<p>Middleware executes in registration order:</p> <pre><code>@app.middleware\ndef first(event, call_next):\n    print(\"1. First - before\")\n    result = call_next(event)\n    print(\"4. First - after\")\n    return result\n\n@app.middleware\ndef second(event, call_next):\n    print(\"2. Second - before\")\n    result = call_next(event)\n    print(\"3. Second - after\")\n    return result\n\n# Output:\n# 1. First - before\n# 2. Second - before\n# (handlers run)\n# 3. Second - after\n# 4. First - after\n</code></pre>"},{"location":"tutorial/middleware/#short-circuiting","title":"Short-Circuiting","text":"<p>Return early to skip handlers:</p> <pre><code>from fasthooks import deny\n\n@app.middleware\ndef auth_check(event, call_next):\n    # Block everything if not authorized\n    if not is_authorized():\n        return deny(\"Not authorized\")\n\n    # Otherwise continue to handlers\n    return call_next(event)\n</code></pre>"},{"location":"tutorial/middleware/#real-world-example","title":"Real-World Example","text":"<pre><code>import time\nimport logging\nfrom fasthooks import HookApp, deny\n\napp = HookApp()\nlogger = logging.getLogger(\"hooks\")\n\n@app.middleware\ndef comprehensive_middleware(event, call_next):\n    # 1. Log incoming event\n    start = time.time()\n    event_info = f\"{event.hook_event_name}\"\n    if hasattr(event, \"tool_name\"):\n        event_info += f\":{event.tool_name}\"\n    logger.info(f\"\u2192 {event_info}\")\n\n    # 2. Skip processing in certain modes\n    if event.permission_mode == \"bypassPermissions\":\n        logger.info(\"  Skipping (bypass mode)\")\n        return None\n\n    # 3. Execute handlers with error handling\n    try:\n        result = call_next(event)\n    except Exception as e:\n        logger.error(f\"  Error: {e}\")\n        return deny(f\"Internal error: {e}\")\n\n    # 4. Log result\n    elapsed = time.time() - start\n    decision = result.decision if result else \"allow\"\n    logger.info(f\"\u2190 {event_info} [{decision}] ({elapsed:.3f}s)\")\n\n    return result\n</code></pre>"},{"location":"tutorial/middleware/#middleware-vs-blueprints-vs-guards","title":"Middleware vs Blueprints vs Guards","text":"Feature Use Case Middleware Universal behavior (timing, logging, auth) Blueprints Organizing handlers by feature Guards Filtering which events trigger a handler <pre><code># Middleware: runs for EVERY event\n@app.middleware\ndef timing(event, call_next): ...\n\n# Blueprint: groups related handlers\nsecurity = Blueprint(\"security\")\n\n# Guard: filters specific handler\n@app.pre_tool(\"Bash\", when=lambda e: \"sudo\" in e.command)\ndef check_sudo(event): ...\n</code></pre>"},{"location":"tutorial/responses/","title":"Responses","text":"<p>Control Claude Code's behavior by returning responses from your handlers.</p>"},{"location":"tutorial/responses/#response-types","title":"Response Types","text":""},{"location":"tutorial/responses/#allow","title":"allow()","text":"<p>Explicitly allow the action. For PreToolUse, bypasses permission prompts.</p> <pre><code>from fasthooks import allow\n\n@app.pre_tool(\"Read\")\ndef allow_docs(event):\n    if event.file_path.endswith(\".md\"):\n        return allow()  # Auto-approve reading markdown\n</code></pre>"},{"location":"tutorial/responses/#denyreason","title":"deny(reason)","text":"<p>Block the action with a reason shown to Claude.</p> <pre><code>from fasthooks import deny\n\n@app.pre_tool(\"Bash\")\ndef no_dangerous(event):\n    if \"rm -rf\" in event.command:\n        return deny(\"Dangerous command blocked\")\n</code></pre>"},{"location":"tutorial/responses/#blockreason","title":"block(reason)","text":"<p>For Stop/SubagentStop hooks - prevent Claude from stopping.</p> <pre><code>from fasthooks import block\n\n@app.on_stop()\ndef ensure_tests(event):\n    # Check if tests were run...\n    if not tests_passed:\n        return block(\"Please run the tests before stopping\")\n</code></pre>"},{"location":"tutorial/responses/#none-implicit-allow","title":"None (implicit allow)","text":"<p>Return <code>None</code> or nothing to allow the action without bypassing permissions.</p> <pre><code>@app.pre_tool(\"Bash\")\ndef check(event):\n    if is_dangerous(event.command):\n        return deny(\"Blocked\")\n    # Implicit allow - normal permission flow continues\n</code></pre>"},{"location":"tutorial/responses/#response-options","title":"Response Options","text":""},{"location":"tutorial/responses/#message","title":"message","text":"<p>Add a system message shown to the user:</p> <pre><code>return allow(message=\"This file is sensitive\")\n</code></pre>"},{"location":"tutorial/responses/#interrupt","title":"interrupt","text":"<p>Stop Claude entirely (not just block this action):</p> <pre><code>return deny(\"Session limit reached\", interrupt=True)\n</code></pre>"},{"location":"tutorial/responses/#response-by-hook-type","title":"Response by Hook Type","text":"Hook Type allow() deny() block() None PreToolUse Bypass permission Block tool - Normal flow PostToolUse - Feedback to Claude - No action PermissionRequest Auto-approve Auto-deny - Show prompt Stop Allow stop - Prevent stop Allow stop"},{"location":"tutorial/responses/#examples","title":"Examples","text":""},{"location":"tutorial/responses/#auto-approve-safe-commands","title":"Auto-approve safe commands","text":"<pre><code>@app.pre_tool(\"Bash\")\ndef auto_approve(event):\n    safe_commands = [\"ls\", \"pwd\", \"echo\", \"cat\"]\n    cmd = event.command.split()[0]\n    if cmd in safe_commands:\n        return allow()\n    # Let other commands go through normal permission flow\n</code></pre>"},{"location":"tutorial/responses/#block-sensitive-files","title":"Block sensitive files","text":"<pre><code>SENSITIVE = [\".env\", \"credentials\", \"secrets\", \".ssh\"]\n\n@app.pre_tool(\"Write\")\ndef protect_sensitive(event):\n    for pattern in SENSITIVE:\n        if pattern in event.file_path:\n            return deny(f\"Cannot write to {pattern} files\")\n</code></pre>"},{"location":"tutorial/responses/#ensure-work-completion","title":"Ensure work completion","text":"<pre><code>@app.on_stop()\ndef check_completion(event):\n    if event.stop_hook_active:\n        return allow()  # Prevent infinite loop\n\n    # Could check transcript, run tests, etc.\n    return block(\"Please verify all tests pass before stopping\")\n</code></pre>"},{"location":"tutorial/testing/","title":"Testing","text":"<p>fasthooks provides utilities for testing your hooks without Claude Code.</p>"},{"location":"tutorial/testing/#mockevent","title":"MockEvent","text":"<p>Create typed test events:</p> <pre><code>from fasthooks.testing import MockEvent\n\n# Create a Bash event\nevent = MockEvent.bash(command=\"ls -la\")\nprint(event.command)  # \"ls -la\"\n\n# Create a Write event\nevent = MockEvent.write(\n    file_path=\"/tmp/test.txt\",\n    content=\"Hello world\"\n)\nprint(event.file_path)  # \"/tmp/test.txt\"\n</code></pre>"},{"location":"tutorial/testing/#available-mock-events","title":"Available Mock Events","text":""},{"location":"tutorial/testing/#tool-events-pretooluse","title":"Tool Events (PreToolUse)","text":"<pre><code>MockEvent.bash(command=\"echo hello\")\nMockEvent.write(file_path=\"/tmp/f.txt\", content=\"...\")\nMockEvent.read(file_path=\"/tmp/f.txt\")\nMockEvent.edit(file_path=\"/tmp/f.txt\", old_string=\"a\", new_string=\"b\")\n</code></pre>"},{"location":"tutorial/testing/#permission-events","title":"Permission Events","text":"<pre><code>MockEvent.permission_bash(command=\"rm -rf /\")\nMockEvent.permission_write(file_path=\"/etc/passwd\", content=\"...\")\nMockEvent.permission_edit(file_path=\"/etc/hosts\", old_string=\"a\", new_string=\"b\")\n</code></pre>"},{"location":"tutorial/testing/#lifecycle-events","title":"Lifecycle Events","text":"<pre><code>MockEvent.stop()\nMockEvent.stop(stop_hook_active=True)\nMockEvent.session_start(source=\"startup\")\nMockEvent.pre_compact(trigger=\"manual\")\n</code></pre>"},{"location":"tutorial/testing/#testclient","title":"TestClient","text":"<p>Test your handlers end-to-end:</p> <pre><code>from fasthooks.testing import TestClient, MockEvent\nfrom my_hooks import app\n\nclient = TestClient(app)\n\ndef test_allows_safe_commands():\n    response = client.send(MockEvent.bash(command=\"ls -la\"))\n    assert response is None  # Allowed\n\ndef test_blocks_dangerous_commands():\n    response = client.send(MockEvent.bash(command=\"rm -rf /\"))\n    assert response.decision == \"deny\"\n    assert \"dangerous\" in response.reason.lower()\n</code></pre>"},{"location":"tutorial/testing/#example-test-file","title":"Example Test File","text":"<pre><code># test_hooks.py\nimport pytest\nfrom fasthooks.testing import TestClient, MockEvent\nfrom hooks import app\n\n@pytest.fixture\ndef client():\n    return TestClient(app)\n\nclass TestBashHooks:\n    def test_allows_ls(self, client):\n        response = client.send(MockEvent.bash(command=\"ls\"))\n        assert response is None\n\n    def test_blocks_rm_rf(self, client):\n        response = client.send(MockEvent.bash(command=\"rm -rf /\"))\n        assert response is not None\n        assert response.decision == \"deny\"\n\nclass TestWriteHooks:\n    def test_blocks_env_files(self, client):\n        response = client.send(MockEvent.write(\n            file_path=\".env\",\n            content=\"SECRET=123\"\n        ))\n        assert response.decision == \"deny\"\n\n    def test_allows_normal_files(self, client):\n        response = client.send(MockEvent.write(\n            file_path=\"readme.md\",\n            content=\"# Hello\"\n        ))\n        assert response is None\n</code></pre> <p>Run tests:</p> <pre><code>pytest test_hooks.py -v\n</code></pre>"},{"location":"tutorial/testing/#cli-testing","title":"CLI Testing","text":"<p>You can also test via the CLI:</p> <pre><code># Generate test event\nfasthooks example bash_dangerous &gt; event.json\n\n# Run hook and check output\nfasthooks run hooks.py --input event.json\n</code></pre> <p>This outputs the JSON response directly, useful for quick manual testing.</p>"},{"location":"tutorial/transcript/","title":"Transcript &amp; Context Engineering","text":"<p>The transcript is Claude's memory - a JSONL file containing the entire conversation history. It's mutable: edit it, and you edit what Claude remembers.</p> <p>\"Claude only knows what's in the transcript. Modify it, and Claude's memory changes.\"</p>"},{"location":"tutorial/transcript/#quick-start","title":"Quick Start","text":"<pre><code>from fasthooks import HookApp\nfrom fasthooks.depends import Transcript\n\napp = HookApp()\n\n@app.on_prompt()\ndef inject_context(event, transcript: Transcript):\n    \"\"\"Add context before Claude responds.\"\"\"\n    from fasthooks.transcript import UserMessage\n\n    # Create a \"memory\" that user mentioned type hints\n    reminder = UserMessage.create(\n        \"Remember: always use type hints in this project\",\n        context=transcript.entries[-1]  # Copy metadata from last entry\n    )\n    transcript.insert(0, reminder)  # Insert at start\n    transcript.save()\n</code></pre>"},{"location":"tutorial/transcript/#the-transcript-model","title":"The Transcript Model","text":""},{"location":"tutorial/transcript/#loading-a-transcript","title":"Loading a Transcript","text":"<pre><code>from fasthooks.transcript import Transcript\n\n# From path\nt = Transcript(\"/path/to/transcript.jsonl\")\n\n# In hooks - auto-injected via DI\n@app.pre_tool(\"Bash\")\ndef check(event, transcript: Transcript):\n    print(f\"Entries: {len(transcript.entries)}\")\n</code></pre>"},{"location":"tutorial/transcript/#entry-types","title":"Entry Types","text":"Type Description <code>UserMessage</code> User input or tool results <code>AssistantMessage</code> Claude's responses <code>SystemEntry</code> System events (compaction, hooks) <code>FileHistorySnapshot</code> File backup for undo <pre><code>from fasthooks.transcript import UserMessage, AssistantMessage\n\nfor entry in transcript.entries:\n    if isinstance(entry, UserMessage):\n        print(f\"User: {entry.text[:50]}...\")\n    elif isinstance(entry, AssistantMessage):\n        print(f\"Claude: {entry.text[:50]}...\")\n        if entry.has_tool_use:\n            for tu in entry.tool_uses:\n                print(f\"  Tool: {tu.name}\")\n</code></pre>"},{"location":"tutorial/transcript/#content-blocks","title":"Content Blocks","text":"<p>Assistant messages contain content blocks:</p> <pre><code>for entry in transcript.assistant_messages:\n    # Text content\n    print(entry.text)\n\n    # Thinking (extended thinking mode)\n    if entry.thinking:\n        print(f\"Thinking: {entry.thinking[:100]}...\")\n\n    # Tool uses\n    for tu in entry.tool_uses:\n        print(f\"Tool: {tu.name}, Input: {tu.input}\")\n\n        # Get the result\n        if tu.result:\n            print(f\"Result: {tu.result.content[:100]}...\")\n            if tu.result.is_error:\n                print(\"  (error)\")\n</code></pre>"},{"location":"tutorial/transcript/#querying","title":"Querying","text":""},{"location":"tutorial/transcript/#pre-built-views","title":"Pre-built Views","text":"<pre><code># Messages by type\ntranscript.user_messages      # List[UserMessage]\ntranscript.assistant_messages # List[AssistantMessage]\n\n# Tool interactions\ntranscript.tool_uses    # All ToolUseBlocks\ntranscript.tool_results # All ToolResultBlocks\ntranscript.errors       # Tool results where is_error=True\n\n# Groupings\ntranscript.turns        # List[Turn] - grouped by requestId\n</code></pre>"},{"location":"tutorial/transcript/#fluent-query-api","title":"Fluent Query API","text":"<p>Inspired by Django ORM and Tidyverse:</p> <pre><code># Type shortcuts\ntranscript.query().users().all()\ntranscript.query().assistants().with_tools().all()\n\n# Filtering\ntranscript.query().filter(type=\"assistant\").all()\ntranscript.query().filter(text__contains=\"error\").all()\ntranscript.query().where(lambda e: e.has_tool_use).all()\n\n# Lookups\ntranscript.query().filter(timestamp__gt=datetime(2024, 1, 1)).all()\ntranscript.query().filter(type__in=[\"user\", \"assistant\"]).all()\n\n# Ordering\ntranscript.query().order_by(\"-timestamp\").limit(10).all()\n\n# Terminals\ntranscript.query().assistants().count()     # int\ntranscript.query().with_errors().exists()   # bool\ntranscript.query().filter(uuid=\"abc\").one() # single entry or ValueError\n</code></pre>"},{"location":"tutorial/transcript/#time-based-queries","title":"Time-based Queries","text":"<pre><code>from datetime import datetime\n\n# Entries since timestamp\ntranscript.query().since(datetime(2024, 1, 1)).all()\ntranscript.query().since(\"2024-01-01T00:00:00\").all()\n\n# Entries until timestamp\ntranscript.query().until(datetime.now()).all()\n</code></pre>"},{"location":"tutorial/transcript/#creating-entries","title":"Creating Entries","text":""},{"location":"tutorial/transcript/#factory-methods","title":"Factory Methods","text":"<pre><code>from fasthooks.transcript import UserMessage, AssistantMessage\n\n# Create user message\nmsg = UserMessage.create(\n    \"Remember to use Python 3.11+\",\n    parent=transcript.entries[-1],  # Sets parent_uuid\n    context=transcript.entries[0],  # Copies session_id, cwd, etc.\n)\n\n# Create assistant message\nresponse = AssistantMessage.create(\n    \"Understood, I'll use Python 3.11+ features.\",\n    parent=msg,\n    model=\"synthetic\",  # Default\n)\n</code></pre> <p>Created entries are marked with <code>is_synthetic=True</code>.</p>"},{"location":"tutorial/transcript/#injecting-tool-results","title":"Injecting Tool Results","text":"<p>For faking tool executions:</p> <pre><code>from fasthooks.transcript import inject_tool_result\n\n# Claude \"remembers\" running this command\nassistant, user = inject_tool_result(\n    transcript,\n    tool_name=\"Read\",\n    tool_input={\"file_path\": \"/project/config.json\"},\n    result='{\"debug\": true, \"log_level\": \"INFO\"}',\n)\n\n# With error\ninject_tool_result(\n    transcript,\n    \"Bash\",\n    {\"command\": \"rm -rf /\"},\n    \"Permission denied\",\n    is_error=True,\n)\n\n# At specific position\ninject_tool_result(transcript, \"Bash\", {...}, \"output\", position=\"start\")\ninject_tool_result(transcript, \"Bash\", {...}, \"output\", position=5)\n</code></pre>"},{"location":"tutorial/transcript/#crud-operations","title":"CRUD Operations","text":""},{"location":"tutorial/transcript/#insert","title":"Insert","text":"<pre><code># At position (rewires parent_uuid chain)\ntranscript.insert(0, entry)      # At start\ntranscript.insert(5, entry)      # At index 5\n\n# At end\ntranscript.append(entry)\n</code></pre>"},{"location":"tutorial/transcript/#remove","title":"Remove","text":"<pre><code># Remove single entry, relink children\ntranscript.remove(entry, relink=True)  # Default\n\n# Remove entry and all descendants\nremoved = transcript.remove_tree(entry)\nprint(f\"Removed {len(removed)} entries\")\n</code></pre>"},{"location":"tutorial/transcript/#replace","title":"Replace","text":"<pre><code># Swap entry, preserve position in chain\ntranscript.replace(old_entry, new_entry)\n</code></pre>"},{"location":"tutorial/transcript/#save","title":"Save","text":"<pre><code># Atomic write (temp file + rename)\ntranscript.save()\n\n# Batch operations with auto-commit/rollback\nwith transcript.batch():\n    transcript.remove(entry1)\n    transcript.insert(0, new_entry)\n    # Auto-saves on success, rollback on exception\n</code></pre>"},{"location":"tutorial/transcript/#statistics","title":"Statistics","text":"<pre><code>stats = transcript.stats\n\n# Token usage\nprint(f\"Input: {stats.input_tokens}\")\nprint(f\"Output: {stats.output_tokens}\")\nprint(f\"Cache read: {stats.cache_read_tokens}\")\n\n# Tool calls\nprint(f\"Tools: {stats.tool_calls}\")  # {\"Bash\": 5, \"Read\": 3}\nprint(f\"Errors: {stats.error_count}\")\n\n# Session info\nprint(f\"Messages: {stats.message_count}\")\nprint(f\"Turns: {stats.turn_count}\")\nprint(f\"Duration: {stats.duration_seconds}s\")\n</code></pre>"},{"location":"tutorial/transcript/#exporting","title":"Exporting","text":""},{"location":"tutorial/transcript/#to-string","title":"To String","text":"<pre><code># Markdown - nice for reading\nmd = transcript.to_markdown()\nmd = transcript.to_markdown(\n    include_thinking=True,      # Show thinking blocks (collapsed)\n    include_tool_input=True,    # Show tool input JSON\n    max_content_length=500,     # Truncate long content\n)\n\n# HTML - for sharing\nhtml = transcript.to_html(title=\"Debug Session\")\n\n# JSON - for processing\njson_str = transcript.to_json(indent=2)\n\n# JSONL - original format\njsonl = transcript.to_jsonl()\n</code></pre>"},{"location":"tutorial/transcript/#to-file","title":"To File","text":"<pre><code>transcript.to_file(\"session.md\")\ntranscript.to_file(\"session.html\", format=\"html\")\ntranscript.to_file(\"session.json\", format=\"json\")\n</code></pre>"},{"location":"tutorial/transcript/#use-cases","title":"Use Cases","text":""},{"location":"tutorial/transcript/#inject-project-context","title":"Inject Project Context","text":"<pre><code>@app.on_session_start()\ndef add_context(event, transcript: Transcript):\n    \"\"\"Inject project guidelines at session start.\"\"\"\n    reminder = UserMessage.create(\n        \"Project rules: Use Black formatting, type hints required, pytest for tests\",\n        context=transcript.entries[0] if transcript.entries else None,\n    )\n    transcript.insert(0, reminder)\n    transcript.save()\n</code></pre>"},{"location":"tutorial/transcript/#redact-sensitive-data","title":"Redact Sensitive Data","text":"<pre><code>@app.on_stop()\ndef redact_secrets(event, transcript: Transcript):\n    \"\"\"Remove API keys from transcript.\"\"\"\n    import re\n    pattern = re.compile(r'sk-[a-zA-Z0-9]{32,}')\n\n    with transcript.batch():\n        for result in transcript.tool_results:\n            if pattern.search(result.content):\n                result.content = pattern.sub('[REDACTED]', result.content)\n</code></pre>"},{"location":"tutorial/transcript/#summarize-large-outputs","title":"Summarize Large Outputs","text":"<pre><code>@app.post_tool(\"Read\")\ndef summarize_large_files(event, transcript: Transcript):\n    \"\"\"Replace large file contents with summary.\"\"\"\n    if len(event.content or \"\") &gt; 5000:\n        for result in transcript.tool_results:\n            if result.tool_use_id == event.tool_use_id:\n                lines = result.content.count('\\n')\n                result.content = f\"[File: {event.file_path}, {lines} lines]\"\n        transcript.save()\n</code></pre>"},{"location":"tutorial/transcript/#analyze-session","title":"Analyze Session","text":"<pre><code>@app.on_stop()\ndef analyze(event, transcript: Transcript):\n    \"\"\"Log session analytics.\"\"\"\n    stats = transcript.stats\n\n    # Check for issues\n    if stats.error_count &gt; 5:\n        print(f\"Warning: {stats.error_count} errors in session\")\n\n    # Export for review\n    if stats.output_tokens &gt; 50000:\n        transcript.to_file(f\"/tmp/large_session_{stats.slug}.md\")\n</code></pre>"},{"location":"tutorial/transcript/#fake-tool-results-for-context","title":"Fake Tool Results for Context","text":"<pre><code>@app.on_prompt()\ndef inject_fake_config(event, transcript: Transcript):\n    \"\"\"Make Claude 'remember' reading a config file.\"\"\"\n    inject_tool_result(\n        transcript,\n        \"Read\",\n        {\"file_path\": \"/project/.claude-config\"},\n        \"prefer_typescript=true\\nmax_file_size=1000\",\n        position=\"start\",\n    )\n    transcript.save()\n</code></pre>"},{"location":"tutorial/transcript/#advanced-archived-entries","title":"Advanced: Archived Entries","text":"<p>Entries before the last context compaction are in <code>transcript.archived</code>:</p> <pre><code># Current context window only (default)\ntranscript.entries\n\n# Pre-compaction entries\ntranscript.archived\n\n# Both\ntranscript.all_entries\n\n# Query with archived\ntranscript.query(include_archived=True).count()\n</code></pre>"},{"location":"tutorial/transcript/#when-do-changes-take-effect","title":"When Do Changes Take Effect?","text":"Hook When Changes Apply <code>on_session_start</code> First response <code>on_prompt</code> Current response <code>pre_tool</code> Next turn (current continues) <code>post_tool</code> Next turn <code>on_stop</code> Next user turn <p>To affect the current response, modify in <code>on_prompt</code> before Claude starts.</p>"}]}